{"version":3,"file":"dist/mceliece.debug.js","sources":["libsodium/src/libsodium/randombytes/randombytes.c","HyMES/arith.c","HyMES/buff.c","HyMES/decrypt.c","HyMES/dicho.c","HyMES/encrypt.c","HyMES/gf.c","HyMES/keypair.c","HyMES/mat.c","HyMES/poly.c","mceliece.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAHA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;AAKA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AALA;AAAA;AAAA;;AAOA;AAAA;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAKA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AACA;AAAA;AAAA;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAJA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AAJA;AAAA;AAAA;;AAWA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AACA;AAkBA;AAAA;;AAfA;AAAA;AACA;AAAA;;AACA;AAAA;AACA;AAYA;AAAA;;AATA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAAA;AAEA;AAAA;AAEA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;AAOA;AAAA;AAGA;AAAA;AAAA;AACA;AAEA;AAAA;;AACA;AAqBA;AAAA;;AAlBA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAMA;AAAA;;AACA;AAGA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;ACxRA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;AAIA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;;;;;;;;;;AAIA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;;;;;;;;;;;;AAuGA;AAEA;;;;;;;;;;;;;;;;;;AA2BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;;;;AA7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;;;;;;;;;;;AAQA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;;;AACA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAmDA;;AAhDA;AAAA;;AACA;AAAA;AAAA;AA+CA;;AA7CA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2CA;;AAzCA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AA8BA;;AA5BA;AAAA;AAEA;;AAuBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AA1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;;AACA;AAqDA;AAAA;;AAnDA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AALA;AAAA;AAAA;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAqCA;AAAA;;AAlCA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AA4BA;AAAA;;AAzBA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAgBA;AAAA;;AAbA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAHA;AAAA;AAAA;AAAA;;AAWA;AAAA;;;AACA;AAAA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AANA;AAAA;AAAA;AAAA;;;;AAUA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAEA;AAAA;;AAmBA;AAAA;AACA;AAAA;AAEA;AAAA;;AApBA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AASA;AAAA;AACA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;;AACA;AAyCA;AAAA;;AAvCA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiCA;AAAA;;AA9BA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAsBA;AAAA;;AAnBA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAYA;AAAA;;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAHA;AAAA;AAAA;AAAA;;AAUA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAPA;AAAA;AAAA;AAAA;;;;AAkBA;AAAA;AAAA;AAQA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAYA;AAAA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AALA;AAAA;AAAA;;;AAOA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAfA;AAAA;AAAA;AAAA;;AAsBA;AAAA;AACA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;;AAFA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAaA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAGA;AAAA;;AADA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;;AAFA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;AAIA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;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A;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAcA;;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;;AAOA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AALA;AAAA;AAAA;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAGA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;AAIA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AAHA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;;;;;;;AAIA;AAAA;AAAA;AACA;;AAAA;AAKA;AAAA;;AAHA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AALA;AAAA;AAAA;;AASA;AAAA;AAEA;AAAA;;;;;;;;;;;;;AAQA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAnBA;AAAA;AAAA;;;AASA;AAAA;AAAA;AAAA;;AAaA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAQA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;;;AARA;AAAA;AAAA;;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAQA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAMA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;;AAMA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAKA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAVA;AAAA;AAAA;;AAgBA;AAAA;;;;;;ACndA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;AAGA;;;;;AAIA;;;;;AAIA;;;;;AAIA;;;;;AAIA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AACA","sourcesContent":["\n#include <stdlib.h>\n#include <sys/types.h>\n\n#include <assert.h>\n#include <limits.h>\n#include <stdint.h>\n\n#ifdef __EMSCRIPTEN__\n# include <emscripten.h>\n#endif\n\n#include \"randombytes.h\"\n#include \"randombytes_sysrandom.h\"\n\n#ifdef __native_client__\n# include \"randombytes_nativeclient.h\"\n#endif\n\n/* C++Builder defines a \"random\" macro */\n#undef random\n\nstatic const randombytes_implementation *implementation;\n\n#ifdef __EMSCRIPTEN__\n# define RANDOMBYTES_DEFAULT_IMPLEMENTATION NULL\n#else\n# ifdef __native_client__\n#  define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_nativeclient_implementation;\n# else\n#  define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_sysrandom_implementation;\n# endif\n#endif\n\nstatic void\nrandombytes_init_if_needed(void)\n{\n    if (implementation == NULL) {\n        implementation = RANDOMBYTES_DEFAULT_IMPLEMENTATION;\n        randombytes_stir();\n    }\n}\n\nint\nrandombytes_set_implementation(randombytes_implementation *impl)\n{\n    implementation = impl;\n\n    return 0;\n}\n\nconst char *\nrandombytes_implementation_name(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->implementation_name();\n#else\n    return \"js\";\n#endif\n}\n\nuint32_t\nrandombytes_random(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->random();\n#else\n    return EM_ASM_INT_V({\n        return Module.getRandomValue();\n    });\n#endif\n}\n\nvoid\nrandombytes_stir(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->stir != NULL) {\n        implementation->stir();\n    }\n#else\n    EM_ASM({\n        if (Module.getRandomValue === undefined) {\n            try {\n                var window_ = \"object\" === typeof window ? window : self,\n                    crypto_ = typeof window_.crypto !== \"undefined\" ? window_.crypto : window_.msCrypto,\n                    randomValuesStandard = function() {\n                        var buf = new Uint32Array(1);\n                        crypto_.getRandomValues(buf);\n                        return buf[0] >>> 0;\n                    };\n                randomValuesStandard();\n                Module.getRandomValue = randomValuesStandard;\n            } catch (e) {\n                try {\n                    var crypto = require('crypto'),\n                        randomValueNodeJS = function() {\n                            var buf = crypto.randomBytes(4);\n                            return (buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3]) >>> 0;\n                        };\n                    randomValueNodeJS();\n                    Module.getRandomValue = randomValueNodeJS;\n                } catch (e) {\n                    throw 'No secure random number generator found';\n                }\n            }\n        }\n    });\n#endif\n}\n\n/*\n * randombytes_uniform() derives from OpenBSD's arc4random_uniform()\n * Copyright (c) 2008, Damien Miller <djm@openbsd.org>\n */\nuint32_t\nrandombytes_uniform(const uint32_t upper_bound)\n{\n    uint32_t min;\n    uint32_t r;\n\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->uniform != NULL) {\n        return implementation->uniform(upper_bound);\n    }\n#endif\n    if (upper_bound < 2) {\n        return 0;\n    }\n    min = (uint32_t) (-upper_bound % upper_bound);\n    do {\n        r = randombytes_random();\n    } while (r < min);\n\n    return r % upper_bound;\n}\n\nvoid\nrandombytes_buf(void * const buf, const size_t size)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (size > (size_t) 0U) {\n        implementation->buf(buf, size);\n    }\n#else\n    unsigned char *p = buf;\n    size_t         i;\n\n    for (i = (size_t) 0U; i < size; i++) {\n        p[i] = (unsigned char) randombytes_random();\n    }\n#endif\n}\n\nint\nrandombytes_close(void)\n{\n    if (implementation != NULL && implementation->close != NULL) {\n        return implementation->close();\n    }\n    return 0;\n}\n\nvoid\nrandombytes(unsigned char * const buf, const unsigned long long buf_len)\n{\n    assert(buf_len <= SIZE_MAX);\n    randombytes_buf(buf, (size_t) buf_len);\n}\n","/*\n* MCE, the real life implementation of McEliece encryption scheme.\n* Copyright Projet SECRET, INRIA, Rocquencourt and Bhaskar Biswas and \n* Nicolas Sendrier (Bhaskar.Biswas@inria.fr, Nicolas.Sendrier@inria.fr).\n*\n* This is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as\n* published by the Free Software Foundation; either version 2.1 of\n* the License, or (at your option) any later version.\n*\n* This software is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this software; if not, write to the Free\n* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n* 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n*/\n#include <stdlib.h>\n#include <stdio.h>\n#include \"arith.h\"\n\nint l2(unsigned long x) {\n  static char table[256] = {\n    0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8\n  };\n\n#if __WORDSIZE == 64\n  if (x >> 32)\n    if (x >> 48)\n      if (x >> 56)\n\treturn table[x >> 56] + 56;\n      else\n\treturn table[x >> 48] + 48;\n    else if (x >> 40)\n      return table[x >> 40] + 40;\n    else\n      return table[x >> 32] + 32;\n  else\n#endif\n    if (x >> 16)\n      if (x >> 24)\n\treturn table[x >> 24] + 24;\n      else\n\treturn table[x >> 16] + 16;\n    else if (x >> 8)\n      return table[x >> 8] + 8;\n    else\n      return table[x];\n}\n\narith_t arith_init(struct buff * b) {\n  arith_t state;\n\n  state = (arith_t) malloc(sizeof (struct code_arith));\n\n  state->min = 0;\n  state->max = (1UL << PREC_INTER);\n  state->compteur = 0;\n  state->buffer = b;\n\n  return state;\n}\n\nint ajuster(arith_t state, int coder) {\n  int i, j;\n  unsigned long x;\n\n  // the current state is the interval [min,max[ = [min,max-1]\n  // this is a subinterval of [0,2^PREC_INTER[\n  // all the integers have PREC_INTER significant bits\n  // the number of leading bits common to all the elements of the\n  // interval is i (computed below)\n  x = (state->max - 1) ^ state->min;\n  i = PREC_INTER - l2(x);\n\n  // we compute j such that\n  // 2^(PREC_INTER - j - 1) <= (max-1)-min < 2^(PREC_INTER - j)\n  // note that j >= i\n  x = (state->max - 1) - state->min;\n  j = PREC_INTER - l2(x) - 1; // watch out the minus 1\n\n  // We want to multiply the range of the interval by 2 as many times\n  // as possible. We can do that at most j times in general (could be\n  // j+1 but it would be difficult to figure out and unnecessary in\n  // practice)\n\n  // if j is greater than i (the number of common leading bits) we can\n  // write i bits in the buffer but we need to keep (j-i) in a counter\n  // for future use (we use here the counter of the previous interval\n  // adjustement)\n\n  if (i > j) // i <= j+1\n    i = j; // we don't write more bits than we remove\n  if (i > 0) {\n    if (coder) {\n      x = state->min >> (PREC_INTER - 1);\n      state->min &= ~(1UL << (PREC_INTER - 1));\n      bwrite_bit(x, state->buffer);\n      bwrite_bits(1 - x, state->compteur, state->buffer);\n      bwrite(state->min >> (PREC_INTER - i), i - 1, state->buffer);\n    }\n    state->compteur = 0;\n  }\n  state->max = (state->max << j) & ((1UL << PREC_INTER) - 1);\n  if (state->max == 0)\n    state->max = 1UL << PREC_INTER;\n  state->min = (state->min << j) & ((1UL << PREC_INTER) - 1);\n  if (j - i > 0) {\n    state->max ^= (1UL << (PREC_INTER - 1));\n    state->min ^= (1UL << (PREC_INTER - 1));\n    state->compteur += j - i;\n  }\n\n  return j;\n}\n\n// codage d'un lment i dans l'intervalle [d.min, d.max]. Les probabilits\n// sont distrib_get_proba(d,d.min),...,distrib_get_proba(d,d.max)\nint coder(int i, distrib_t d, arith_t state) {\n  unsigned long x;\n  unsigned long delta;\n  int l;\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\t%u\\n\", state->min, state->max, i);\n#endif\n\n  delta = state->max - state->min;\n\n  // pour tre synchronis avec decoder()\n  bwrite_lock(PREC_INTER + state->compteur, state->buffer);\n\n  if (i < d.max) {\n    x = distrib_get_proba(d, i + 1);\n    x *= delta;\n    x >>= PREC_PROBA;\n    state->max = state->min + x;\n  }\n  x = distrib_get_proba(d, i);\n  x *= delta;\n  x >>= PREC_PROBA;\n  state->min += x;\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\n\", state->min, state->max);\n#endif\n\n  l = ajuster(state, 1);\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\n\", state->min, state->max);\n#endif\n\n  return l;\n}\n\n// loi uniforme 0 <= i < n\nint coder_uniforme(unsigned long i, unsigned long n, arith_t state) {\n  unsigned long x;\n  unsigned long delta;\n  int l;\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\t%u\\t*%u\\n\", state->min, state->max, i, n);\n#endif\n\n  delta = state->max - state->min;\n\n  // pour tre synchronis avec decoder_uniforme()\n  bwrite_lock(PREC_INTER + state->compteur, state->buffer);\n\n  x = i;\n  x *= delta;\n  // normalement pas de risque dedpassement avec x + delta <= n * delta\n  state->max = state->min + ((x + delta) / n);\n  state->min += x / n;\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\n\", state->min, state->max);\n#endif\n\n  l = ajuster(state, 1);\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\n\", state->min, state->max);\n#endif\n\n  return l;\n}\n\nint chercher(unsigned long valeur, unsigned long * sprob, int a, int b) {\n  if (b - a == 1)\n    return a;\n  else {\n    int m = (a + b) / 2;\n    if (sprob[m] > valeur)\n      return chercher(valeur, sprob, a, m);\n    else\n      return chercher(valeur, sprob, m, b);\n  }\n}\n\n// dcodage d'un lment dans l'intervalle [d.min,d.max]. Les\n// probabilits sont distrib_get_proba(d,d.min),...,distrib_get_proba(d,d.max)\nint decoder(distrib_t d, int * lettre, arith_t state) {\n  unsigned long x;\n  unsigned long delta, valeur;\n  int i, r;\n\n  delta = state->max - state->min;\n\n  if (state->compteur)\n    valeur = blook(PREC_INTER, state->buffer) ^ (1UL << (PREC_INTER - 1));\n  else\n    valeur = blook(PREC_INTER, state->buffer);\n\n  bread_lock(PREC_INTER, state->buffer);\n\n  x = valeur - state->min;\n  x <<= PREC_PROBA;\n  x /= delta;\n  // appel dependant de la structure distrib_t (a changer ?)\n  i = d.min + chercher(x, d.prob, 0, d.max - d.min + 1);\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\t\", state->min, state->max);\n#endif\n\n  if (i < d.max) {\n    x = distrib_get_proba(d, i + 1);\n    x *= delta;\n    x >>= PREC_PROBA;\n    x += state->min;\n    if (valeur >= x) { // il faut augmenter i\n      ++i;\n      if (i < d.max) {\n\tx = distrib_get_proba(d, i + 1);\n\tx *= delta;\n\tx >>= PREC_PROBA;\n\tstate->max = state->min + x;\n      }\n    }\n    else\n      state->max = x;\n  }\n  x = distrib_get_proba(d, i);\n  x *= delta;\n  x >>= PREC_PROBA;\n  state->min += x;\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\n\", i, valeur);\n#endif\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\n\", state->min, state->max);\n#endif\n\n  r = ajuster(state, 0);\n  bstep(r, state->buffer);\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\n\", state->min, state->max);\n#endif\n\n  *lettre = i;\n  return r;\n}\n\n// loi uniforme 0 <= i < n\nunsigned long decoder_uniforme(unsigned long n, unsigned long * lettre, arith_t state) {\n  unsigned long x;\n  unsigned long delta, valeur;\n  int i, r;\n\n  delta = state->max - state->min;\n\n  if (state->compteur)\n    valeur = blook(PREC_INTER, state->buffer) ^ (1UL << (PREC_INTER - 1));\n  else\n    valeur = blook(PREC_INTER, state->buffer);\n\n  bread_lock(PREC_INTER, state->buffer);\n\n  x = valeur - state->min;\n  x *= n;\n  x /= delta;\n  i = x;\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\t\", state->min, state->max);\n#endif\n\n  x = i;\n  x *= delta;\n  state->max = state->min + ((x + delta) / n);\n  // test obligatoire car max arrondi infrieurement\n  if (valeur >= state->max) { // il faut augmenter i\n    ++i;\n    x += delta;\n    state->max = state->min + ((x + delta) / n);\n  }\n  state->min += x / n;\n\n#ifdef DEBUG\n  printf(\"%u\\t*%u\\n\", i, n);\n#endif\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\n\", state->min, state->max);\n#endif\n\n  r = ajuster(state, 0);\n  bstep(r, state->buffer);\n\n#ifdef DEBUG\n  printf(\"%u\\t%u\\n\", state->min, state->max);\n#endif\n\n  *lettre = i;\n  return r;\n}\n","/*\n* MCE, the real life implementation of McEliece encryption scheme.\n* Copyright Projet SECRET, INRIA, Rocquencourt and Bhaskar Biswas and \n* Nicolas Sendrier (Bhaskar.Biswas@inria.fr, Nicolas.Sendrier@inria.fr).\n*\n* This is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as\n* published by the Free Software Foundation; either version 2.1 of\n* the License, or (at your option) any later version.\n*\n* This software is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this software; if not, write to the Free\n* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n* 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n*/\n#include <stdlib.h>\n#include \"buff.h\"\n\n#define LSB_TO_ONE(i) ((i) ? ((1UL << (i)) - 1) : 0)\n#define LSB_TO_ZERO(i) (((i) == BUFFSIZE) ? 0 : (((unsigned long) -1) << (i)))\n\nunsigned char bread_getchar(bread_t bin) {\n  bin->courant++;\n  if (bin->courant < bin->dernier)\n    return bin->message[bin->courant];\n  if (bin->courant == bin->dernier)\n    return bin->message[bin->courant] & bin->masque_dernier;\n  return 0;\n}\n\nvoid bwrite_putchar(unsigned char c, bwrite_t bout) {\n  bout->courant++;\n  if (bout->courant < bout->dernier)\n    bout->message[bout->courant] = c;\n  if (bout->courant == bout->dernier) {\n    bout->message[bout->courant] &= ~ bout->masque_dernier;\n    bout->message[bout->courant] ^= c & bout->masque_dernier;\n  }\n}\n\nbread_t breadinit(unsigned char * message, int fin) {\n  bread_t bin;\n\n  bin = malloc (sizeof (struct buff));\n\n  bin->message = message;\n  bin->fin = fin;\n  // adresse du dernier octet\n  bin->dernier = (fin - 1) / 8;\n  // masque  appliquer au dernier octet\n  bin->masque_dernier = LSB_TO_ZERO((-fin) & 0x7);\n\n  bin->courant = -1;\n  bin->val = 0;\n  bin->size = 0;\n  bin->lock = 0;\n\n  return bin;\n}\n\nbwrite_t bwriteinit(unsigned char * message, int fin) {\n  bwrite_t bout;\n\n  bout = malloc (sizeof (struct buff));\n\n  bout->message = message;\n  bout->fin = fin;\n  // adresse du dernier octet\n  bout->dernier = (fin - 1) / 8;\n  // masque  appliquer au dernier octet\n  bout->masque_dernier = LSB_TO_ZERO((-fin) & 0x7);\n\n  bout->courant = -1;\n  bout->val = 0;\n  bout->size = BUFFSIZE;\n  bout->lock = 0;\n\n  return bout;\n}\n\n// uniquement sur un buffer vide\nvoid bfill(bread_t bin) {\n  int i;\n\n  for (i = 0; i < BUFFSIZE; i += 8) {\n    bin->val <<= 8;\n    bin->val ^= bread_getchar(bin);\n  }\n  bin->size = BUFFSIZE;\n}\n\n// uniquement sur un buffer plein (sinon bflush_partiel)\nvoid bflush(bwrite_t bout) {\n  int i;\n\n  for (i = BUFFSIZE - 8; i >= 0; i -= 8)\n    bwrite_putchar(bout->val >> i, bout);\n  bout->val = 0;\n  bout->size = BUFFSIZE;\n}\n\nvoid bflush_partiel(bwrite_t bout) {\n  int i;\n\n  for (i = BUFFSIZE - 8; i >= bout->size; i -= 8)\n    bwrite_putchar(bout->val >> i, bout);\n  bout->size -= i;\n  // 8 >= bout->size > 0\n  if (bout->size < 8) { // sinon, bout->size == 8 et on a fini\n    // Il reste (8 - bout->size) bits  crire, mais sans en craser d'autres\n    // On met les bits qui nous intressent dans le premier octet de bout->val\n    bout->val >>= i;\n    // On masque les bout->size bits les moins significatifs\n    bout->val &= LSB_TO_ZERO(bout->size);\n\n    // Un peu hrtique (un read sur un bwrite_t) mais c'est ce qu'il\n    // faut. On rcupre (dans les bits les moins significatifs de\n    // bout->val) les bout->size bits de l'octet courant (ils doivent\n    // rester intacts)\n    bout->val ^= bread_getchar(bout) & LSB_TO_ONE(bout->size);\n    // on recule car on va rcrire l'octet courant\n    bout->courant--;\n    bwrite_putchar(bout->val, bout);\n  }\n  bout->val = 0;\n  bout->size = BUFFSIZE;\n}\n\nvoid breadclose(bread_t bin) {\n  free(bin);\n}\n\nvoid bwriteclose(bwrite_t bout) {\n  bflush_partiel(bout);\n  free(bout);\n}\n\nvoid bread_retour(bread_t bin) {\n  bin->courant = -1;\n  bin->size = 0;\n  bin->val = 0;\n}\n\n// nombre de bits disponibles (peut etre < 0)\nint bread_available(bread_t bin) {\n  return bin->fin - 8 * (bin->courant + 1) + bin->size;\n}\n\n// nombre de bits disponibles (peut etre < 0)\nint bwrite_available(bwrite_t bout) {\n  return bout->fin - 8 * (bout->courant + 1) - BUFFSIZE + bout->size;\n}\n\n// nombre de bits disponibles aprs le verrou\nint bread_unlocked(bread_t bin) {\n  return bin->fin - bin->lock;\n}\n\n// nombre de bits disponibles aprs le verrou\nint bwrite_unlocked(bwrite_t bout) {\n  return bout->fin - bout->lock;\n}\n\nint bread_position(bread_t bin) {\n  return 8 * (bin->courant + 1) - bin->size;\n}\n\nvoid bread_changer_position(bread_t bin, int i) {\n  // adresse prcdant l'octet contenant le i-ime bit\n  bin->courant = i / 8 - 1;\n  // on place l'octet du i-eme bit dans bin->val\n  bin->val = bread_getchar(bin);\n  // le nombre de bits \"utiles\" dans l'octet courant\n  bin->size = 8 - (i % 8);\n}\n\n// si i < 0, on recule\nvoid bread_decaler_fin(bread_t bin, int i) {\n  bin->fin += i;\n  bin->dernier = (bin->fin - 1) / 8;\n  bin->masque_dernier = LSB_TO_ZERO((-bin->fin) & 0x7);\n  bread_changer_position(bin, bread_position(bin));\n}\n\nvoid bwrite_changer_position(bwrite_t bout, int i) {\n  // On commence par faire table rase du pass.\n  // Si bout->size == BUFFSIZE (aprs init par ex.) il ne se passera\n  // rien avec bflush_partiel(), sinon il faut crire qq bits en\n  // prenant garde de ne rien craser\n  bflush_partiel(bout);\n  // adresse prcdant l'octet contenant le i-ime bit\n  // l'criture recommencera  partir de l'octet bout->courant + 1\n  bout->courant = i / 8 - 1;\n  // le nombre de bits restant \" crire\" dans le buffer\n  bout->size = BUFFSIZE - (i % 8);\n  if (i % 8 == 0)\n    bout->val = 0;\n  else {\n    // on place l'octet du i-eme bit au dbut de bout->val\n    bout->val = ((unsigned long) bout->message[i / 8]) << (BUFFSIZE - 8);\n    // On efface les bout->size derniers bits de bout->val\n    bout->val &= LSB_TO_ZERO(bout->size);\n  }\n}\n\n// si i < 0, on recule\nvoid bwrite_decaler_fin(bwrite_t bout, int i) {\n  bout->fin += i;\n  bout->dernier = (bout->fin - 1) / 8;\n  bout->masque_dernier = LSB_TO_ZERO((-bout->fin) & 0x7);\n}\n\n// suppose i <= BUFFSIZE\nunsigned bread(int i, bread_t bin) {\n  unsigned res = 0;\n\n  if (bin->size < i) {\n    res = bin->val & LSB_TO_ONE(bin->size);\n    i -= bin->size;\n    res <<= i;\n    bfill(bin);\n  }\n  bin->size -= i;\n  res ^= (bin->val >> bin->size) & LSB_TO_ONE(i);\n\n  return res;\n}\n\nvoid bread_lock(int i, bread_t bin) {\n  bin->lock = 8 * (bin->courant + 1) - bin->size + i;\n}\n\nvoid bwrite_lock(int i, bwrite_t bout) {\n  bout->lock = 8 * (bout->courant + 1) + BUFFSIZE - bout->size + i;\n}\n\n// suppose i <= BUFFSIZE - 8\n// comme bread mais on n'avance pas dans le buffer\nunsigned blook(int i, bread_t bin) {\n  unsigned res = 0;\n\n  while (bin->size < i) {\n    bin->val <<= 8;\n    bin->val ^= bread_getchar(bin);\n    bin->size += 8;\n  }\n  res ^= (bin->val >> (bin->size - i)) & LSB_TO_ONE(i);\n\n  return res;\n}\n\n// suppose i <= BUFFSIZE\nvoid bstep(int i, bread_t bin) {\n  if (bin->size < i) {\n    i -= bin->size;\n    bfill(bin);\n  }\n  bin->size -= i;\n}\n\nint bread_bit(bread_t bin) {\n  if (bin->size <= 0)\n    bfill(bin);\n  bin->size--;\n  return (bin->val >> bin->size) & 1;\n}\n\n// On suppose i <= BUFFSIZE et x < (1 << i)\nvoid bwrite(unsigned int x, int i, bwrite_t bout) {\n  if (bout->size < i) { // pas assez de place\n    i -= bout->size;\n    bout->val ^= x >> i;\n    bflush(bout);\n    x &= LSB_TO_ONE(i);\n  }\n  // i <= bout->size\n  bout->size -= i;\n  bout->val ^= x << bout->size;\n}\n\n// x = 0 ou 1\nvoid bwrite_bit(unsigned int x, bwrite_t bout) {\n  if (bout->size <= 0)\n    bflush(bout);\n  bout->size--;\n  bout->val ^= x << bout->size;\n}\n\n// x = 0 ou 1\nvoid bwrite_bits(unsigned int x, int n, bwrite_t bout) {\n  if (bout->size <= 0)\n    bflush(bout);\n  x = x ? -1 : 0;\n  if (n > bout->size) { // pas assez de place\n    bout->val ^= x >> (BUFFSIZE - bout->size);\n    n -= bout->size;\n    bflush(bout);\n    while (n > BUFFSIZE) { // toujours pas assez de place\n      bout->val = x;\n      n -= BUFFSIZE;\n      bflush(bout);\n    }\n  }\n  if (n > 0) {\n    bout->size -= n;\n    bout->val ^= (x >> (BUFFSIZE - n)) << bout->size;\n  }\n}\n","/*\n* MCE, the real life implementation of McEliece encryption scheme.\n* Copyright Projet SECRET, INRIA, Rocquencourt and Bhaskar Biswas and \n* Nicolas Sendrier (Bhaskar.Biswas@inria.fr, Nicolas.Sendrier@inria.fr).\n*\n* This is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as\n* published by the Free Software Foundation; either version 2.1 of\n* the License, or (at your option) any later version.\n*\n* This software is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this software; if not, write to the Free\n* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n* 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n*/\n#include <stdlib.h>\n#include <string.h>\n#include \"sizes.h\"\n#include \"gf.h\"\n#include \"poly.h\"\n#include \"dicho.h\"\n#include \"randomize.h\"\n\nextern precomp_t cwdata;\n\npoly_t g, sqrtmod[NB_ERRORS];\ngf_t * Linv;\nunsigned long * coeffs;\n\nvoid sk_from_string(const unsigned char * sk)\n{\n  int i;\n  // L, g, coeffs and sqrt declared as global variables:\n  // gf_t *Linv, *coeffs;\n  // poly_t g, sqrtmod[NB_ERRORS];\n\n  coeffs = (unsigned long *) sk;\n  sk += LENGTH *  BITS_TO_LONG(CODIMENSION) * sizeof (long);\n\n  Linv = (gf_t *) sk;\n  sk += LENGTH * sizeof (gf_t);\n\n  g = poly_alloc_from_string(NB_ERRORS, sk);\n  poly_set_deg(g, NB_ERRORS);\n  sk += (NB_ERRORS + 1) * sizeof (gf_t);\n\n  for (i = 0; i < NB_ERRORS; ++i) {\n    sqrtmod[i] = poly_alloc_from_string(NB_ERRORS - 1, sk);\n    poly_set_deg(sqrtmod[i], NB_ERRORS - 1);\n    sk += NB_ERRORS * sizeof (gf_t);\n  }\n}\n\nvoid sk_free()\n{\n  int i;\n\n  free(g);\n  for (i = 0; i < NB_ERRORS; ++i) {\n    free(sqrtmod[i]);\n  }\n}\n\nvoid xor(unsigned long * a, unsigned long * b) {\n  int i;\n\n  for (i = 0; i < BITS_TO_LONG(CODIMENSION); ++i)\n    a[i] ^= b[i];\n}\n\n// syndrome computation is affected by the vec_concat procedure (see encrypt.c)\npoly_t syndrome(const unsigned char * b)\n{\n  int i, j, k, l;\n  poly_t R;\n  gf_t a;\n  unsigned long c[BITS_TO_LONG(CODIMENSION)];\n\n  memset(c, 0, BITS_TO_LONG(CODIMENSION) * sizeof (long));\n\n  R = poly_alloc(NB_ERRORS - 1);\n  for (j = 0; j < LENGTH; j++)\n    {\n      if ((b[j / 8] >> (j % 8)) & 1)\n\txor(c, coeffs + j * BITS_TO_LONG(CODIMENSION));\n    }\n\n  // transform the binary vector c of length EXT_DEGREE * NB_ERRORS in\n  // a polynomial of degree NB_ERRORS\n  for (l = 0; l < NB_ERRORS; ++l) {\n    k = (l * EXT_DEGREE) / BIT_SIZE_OF_LONG;\n    j = (l * EXT_DEGREE) % BIT_SIZE_OF_LONG;\n    a = c[k] >> j;\n    if (j + EXT_DEGREE > BIT_SIZE_OF_LONG)\n      a ^= c[k + 1] << (BIT_SIZE_OF_LONG - j);\n    a &= ((1 << EXT_DEGREE) - 1);\n    poly_set_coeff(R, l, a);\n  }\n\n  poly_calcule_deg(R);\n  return R;\n}\n\nint roots_berl_aux(poly_t sigma, int d, poly_t * tr_aux, poly_t * tr, int e, gf_t * res) {\n  poly_t gcd1, gcd2;\n  int i, j;\n  gf_t a;\n\n  if (d == 0) {\n    return 0;\n  }\n\n  if (d == 1) {\n    *res = gf_div(poly_coeff(sigma, 0), poly_coeff(sigma, 1));\n    return 1;\n  }\n\n  // not before because we may have e == EXT_DEGREE and d == 1\n  if (e >= EXT_DEGREE) {\n    return 0;\n  }\n\n  if (tr[e] == NULL) {\n    tr[e] = poly_alloc(NB_ERRORS - 1);\n    a = gf_exp(e);\n    for (i = 0; i < EXT_DEGREE; ++i) {\n      for (j = 0; j < NB_ERRORS; ++j)\n\tpoly_addto_coeff(tr[e], j, gf_mul(poly_coeff(tr_aux[i], j), a));\n      a = gf_square(a);\n    }\n    poly_calcule_deg(tr[e]);\n  }\n  gcd1 = poly_gcd(tr[e], sigma);\n  gcd2 = poly_quo(sigma, gcd1);\n\n  i = poly_deg(gcd1);\n\n  j = roots_berl_aux(gcd1, i, tr_aux, tr, e + 1, res);\n  j += roots_berl_aux(gcd2, d - i, tr_aux, tr, e + 1, res + j);\n\n  poly_free(gcd1);\n  poly_free(gcd2);\n\n  return j;\n}\n\nint roots_berl(poly_t sigma, gf_t * res) {\n  poly_t * sq_aux, * tr, * tr_aux;\n  int i, j, d;\n  gf_t a;\n\n  sq_aux = malloc(NB_ERRORS * sizeof (poly_t));\n  tr_aux = malloc(EXT_DEGREE * sizeof (poly_t));\n  tr = malloc(EXT_DEGREE * sizeof (poly_t));\n  for (i = 0; i < NB_ERRORS; ++i)\n    sq_aux[i] = poly_alloc(NB_ERRORS + 1);\n  for (i = 0; i < EXT_DEGREE; ++i)\n    tr_aux[i] = poly_alloc(NB_ERRORS - 1);\n  for (i = 0; i < EXT_DEGREE; ++i)\n    tr[i] = NULL;\n\n  poly_sqmod_init(sigma, sq_aux);\n  poly_set_coeff(tr_aux[0], 1, gf_unit());\n  poly_set_deg(tr_aux[0], 1);\n  tr[0] = poly_alloc(NB_ERRORS - 1);\n  poly_set_coeff(tr[0], 1, gf_unit());\n  for (i = 1; i < EXT_DEGREE; ++i) {\n    poly_sqmod(tr_aux[i], tr_aux[i - 1], sq_aux, NB_ERRORS);\n    for (j = 0; j < NB_ERRORS; ++j)\n      poly_addto_coeff(tr[0], j, poly_coeff(tr_aux[i], j));\n  }\n  poly_calcule_deg(tr[0]);\n  for (i = 0; i < NB_ERRORS; ++i)\n    poly_free(sq_aux[i]);\n  free(sq_aux);\n  d = roots_berl_aux(sigma, NB_ERRORS, tr_aux, tr, 0, res);\n  for (i = 0; i < EXT_DEGREE; ++i)\n    poly_free(tr_aux[i]);\n  free(tr_aux);\n  for (i = 0; i < EXT_DEGREE; ++i)\n    if (tr[i] != NULL)\n      poly_free(tr[i]);\n  free(tr);\n\n  return d;\n}\n\nint partition (int * tableau, int gauche, int droite, int pivot) {\n  int i, temp;\n  for (i = gauche; i < droite; i++)\n    if (tableau[i] <= pivot) {\n      temp = tableau[i];\n      tableau[i] = tableau[gauche];\n      tableau[gauche] = temp;\n      ++gauche;\n    }\n  return gauche;\n}\n\nvoid quickSort(int * tableau, int gauche, int droite, int min, int max) {\n  if (gauche < droite - 1) {\n    int milieu = partition(tableau, gauche, droite, (max + min) / 2);\n    quickSort(tableau, gauche, milieu, min, (max + min) / 2);\n    quickSort(tableau, milieu, droite, (max + min) / 2, max);\n  }\n}\n\nint decode(const unsigned char * b, int * e)\n{\n  int i,j,d;\n  poly_t u,v,h,sigma,R,S,aux;\n  gf_t a, res[NB_ERRORS];\n\n  gf_init(EXT_DEGREE);\n  R = syndrome(b);\n\n  //1. Compute S(z), such that, S(z)^2=(h(z)+z)%g(z).\n  //2. Compute u(z),v(z), such that, deg(u)<=t/2, deg(v)<=(t-1)/2 and u(z)=S(z).v(z)%g(z).\n  //3. Compute Sigma_e(z)=u(z^2)+z(v(z)^2).->The locator polynomial of the code C.\n\n  poly_eeaux(&h ,&aux, R, g, 1);\n  a = gf_inv(poly_coeff(aux,0));\n  for (i = 0; i <= poly_deg(h); ++i)\n    poly_set_coeff(h,i,gf_mul_fast(a,poly_coeff(h,i)));\n  poly_free(aux);\n  poly_free(R);\n\n  //  compute h(z) += z\n  poly_addto_coeff(h, 1, gf_unit());\n\n  // compute S square root of h (using sqrtmod)\n  S = poly_alloc(NB_ERRORS - 1);\n  for(i=0;i<NB_ERRORS;i++) {\n    a = gf_sqrt(poly_coeff(h,i));\n    if (a != gf_zero()) {\n      if (i & 1) {\n\tfor(j=0;j<NB_ERRORS;j++)\n\t  poly_addto_coeff(S, j, gf_mul_fast(a, poly_coeff(sqrtmod[i],j)));\n      }\n      else\n\tpoly_addto_coeff(S, i/2, a);\n    }\n  }\n  poly_calcule_deg(S);\n  poly_free(h);\n\n  // solve the key equation u(z) = v(z)*S(z) mod g(z)\n  poly_eeaux(&v, &u, S, g, NB_ERRORS/2+1);\n  poly_free(S);\n\n  // sigma = u^2+z*v^2\n  sigma = poly_alloc(NB_ERRORS);\n  for (i = 0; i <= poly_deg(u); ++i) {\n    poly_set_coeff(sigma, 2*i, gf_square(poly_coeff(u,i)));\n  }\n  for (i = 0; i <= poly_deg(v); ++i) {\n    poly_set_coeff(sigma, 2*i+1, gf_square(poly_coeff(v,i)));\n  }\n  poly_free(u);\n  poly_free(v);\n\n  poly_calcule_deg(sigma);\n\n  d = poly_deg(sigma);\n  if (d != NB_ERRORS) {\n    poly_free(sigma);\n    return -1;\n  }\n\n  d = roots_berl(sigma, res);\n  if (d != NB_ERRORS) {\n    poly_free(sigma);\n    return -1;\n  }\n\n  for (i = 0; i < d; ++i)\n    e[i] = Linv[res[i]];\n\n  // we need the error pattern sorted in increasing order\n  quickSort(e, 0, NB_ERRORS, 0, 1 << EXT_DEGREE);\n\n  poly_free(sigma);\n\n  return d;\n}\n\nint decrypt_block(unsigned char *cleartext, unsigned char *ciphertext, const unsigned char * sk)\n{\n  int i, j, k, l, e[NB_ERRORS];\n  unsigned char c;\n\n  sk_from_string(sk);\n\n  // assumes e is ordered\n  i = decode(ciphertext, e);\n  sk_free();\n\n  if (i < 0)\n    return -1;\n\n  // flip t error positions\n  for (i = 0; i < NB_ERRORS; i++)\n    ciphertext[e[i] / 8] ^= (1 << (e[i] % 8)); // As 8 is the length of unsigned char.\n\n  memcpy(cleartext, ciphertext, BITS_TO_BYTES(DIMENSION));\n\n  // writes into cleartext a binary bit stream of length ERROR_SIZE\n  // starting at position DIMENSION corresponding to the error pattern\n  // in cw\n  i = dicho_cw2b(e, cleartext,\n\t\t DIMENSION, ERROR_SIZE,\n\t\t LOG_LENGTH, ERROR_WEIGHT, cwdata);\n  // returns the number of bits used (i < 0 if less than ERROR_SIZE\n  // bits are used)\n\n  if (i < 0)\n    return -1;\n\n  return 1;\n}\n\n// The suffix _ss is for \"semantically secure\", the ciphertext is\n// decrypted into cleartext which is unrandomize into message with a\n// consistency check\nint decrypt_block_ss(unsigned char *message, unsigned char *ciphertext, const unsigned char * sk)\n{\n  int i;\n  unsigned char cleartext[CLEARTEXT_LENGTH];\n\n  i = decrypt_block(cleartext, ciphertext, sk);\n\n  if (i > 0)\n    // returns a negative number in case of an unconsistent block\n    return unrandomize(message, cleartext);\n\n  return i;\n}\n","/*\n* MCE, the real life implementation of McEliece encryption scheme.\n* Copyright Projet SECRET, INRIA, Rocquencourt and Bhaskar Biswas and \n* Nicolas Sendrier (Bhaskar.Biswas@inria.fr, Nicolas.Sendrier@inria.fr).\n*\n* This is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as\n* published by the Free Software Foundation; either version 2.1 of\n* the License, or (at your option) any later version.\n*\n* This software is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this software; if not, write to the Free\n* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n* 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n*/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include \"buff.h\"\n#include \"arith.h\"\n#include \"precomp.h\"\n\ndouble round(double);\nint l2(unsigned long x);\n\ntypedef struct elt {\n  int * element;\n  int taille, nombre;\n  int pos;\n  unsigned long valeur, maximum;\n  struct elt * suivant;\n} * liste_t;\n\nliste_t liste_todo;\nliste_t liste_inv;\nint * aux;\n\nliste_t liste_alloc(liste_t s) {\n  liste_t l =  (liste_t) malloc(sizeof (struct elt));\n  l->suivant = s;\n  return l;\n}\n\nvoid liste_free(liste_t l) {\n  if (l != NULL)\n    liste_free(l->suivant);\n  free(l);\n}\n\nint is_leaf(int m, int t) {\n  static int feuille[6] = {7, 5, 4, 4, 3, 3};\n  if (m < 6)\n    return (t <= 32);\n  else if (m > 16)\n    return (t <= 1);\n  else if (m > 11)\n    return (t <= 2);\n  else\n    return (feuille[m - 6] >= t);\n}\n\nint max_bino[] = {0, 0, 0, 0, 0, 128, 64, 64, 32, 32, 32, 32, 32, 32, 32, 32, 32};\nunsigned long * table_bino[] = {\n  NULL, // 0\n  NULL, // 1\n  NULL, // 2\n  NULL, // 3\n  NULL, // 4\n  (unsigned long [129]) { // 5\n    0U, 0U, 0U, 0U, 0U, 1U, 6U, 21U, 56U, 126U, 252U, 462U, 792U,\n    1287U, 2002U, 3003U, 4368U, 6188U, 8568U, 11628U, 15504U, 20349U,\n    26334U, 33649U, 42504U, 53130U, 65780U, 80730U, 98280U, 118755U,\n    142506U, 169911U, 201376U, 237336U, 278256U, 324632U, 376992U,\n    435897U, 501942U, 575757U, 658008U, 749398U, 850668U, 962598U,\n    1086008U, 1221759U, 1370754U, 1533939U, 1712304U, 1906884U,\n    2118760U, 2349060U, 2598960U, 2869685U, 3162510U, 3478761U,\n    3819816U, 4187106U, 4582116U, 5006386U, 5461512U, 5949147U,\n    6471002U, 7028847U, 7624512U, 8259888U, 8936928U, 9657648U,\n    10424128U, 11238513U, 12103014U, 13019909U, 13991544U, 15020334U,\n    16108764U, 17259390U, 18474840U, 19757815U,21111090U, 22537515U,\n    24040016U, 25621596U, 27285336U, 29034396U, 30872016U, 32801517U,\n    34826302U, 36949857U,39175752U, 41507642U, 43949268U, 46504458U,\n    49177128U, 51971283U, 54891018U, 57940519U, 61124064U,\n    64446024U,67910864U, 71523144U, 75287520U, 79208745U, 83291670U,\n    87541245U, 91962520U, 96560646U, 101340876U, 106308566U,\n    111469176U, 116828271U, 122391522U, 128164707U, 134153712U,\n    140364532U, 146803272U, 153476148U, 160389488U,167549733U,\n    174963438U, 182637273U, 190578024U, 198792594U, 207288004U,\n    216071394U, 225150024U, 234531275U, 244222650U, 254231775U,\n    264566400U},\n  (unsigned long [65]) { // 6\n    0U, 0U, 0U, 0U, 0U, 0U, 1U, 7U, 28U, 84U, 210U, 462U, 924U, 1716U,\n    3003U, 5005U, 8008U, 12376U, 18564U, 27132U, 38760U, 54264U,\n    74613U, 100947U, 134596U, 177100U, 230230U, 296010U, 376740U,\n    475020U, 593775U, 736281U, 906192U, 1107568U, 1344904U, 1623160U,\n    1947792U, 2324784U, 2760681U, 3262623U, 3838380U, 4496388U,\n    5245786U, 6096454U, 7059052U, 8145060U, 9366819U, 10737573U,\n    12271512U, 13983816U, 15890700U, 18009460U, 20358520U, 22957480U,\n    25827165U, 28989675U, 32468436U, 36288252U, 40475358U, 45057474U,\n    50063860U, 55525372U, 61474519U, 67945521U,74974368U},\n  (unsigned long [65]) { // 7\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U, 8U, 36U, 120U, 330U, 792U, 1716U,\n    3432U, 6435U, 11440U, 19448U, 31824U, 50388U, 77520U, 116280U,\n    170544U, 245157U, 346104U, 480700U, 657800U, 888030U, 1184040U,\n    1560780U, 2035800U, 2629575U, 3365856U,4272048U, 5379616U,\n    6724520U, 8347680U, 10295472U, 12620256U, 15380937U, 18643560U,\n    22481940U, 26978328U, 32224114U, 38320568U, 45379620U, 53524680U,\n    62891499U, 73629072U, 85900584U, 99884400U, 115775100U,\n    133784560U, 154143080U, 177100560U, 202927725U, 231917400U,\n    264385836U, 300674088U, 341149446U, 386206920U,\n    436270780U,491796152U, 553270671U, 621216192U},\n  (unsigned long [33]) { // 8\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U, 9U, 45U, 165U, 495U, 1287U,\n    3003U, 6435U, 12870U, 24310U, 43758U, 75582U, 125970U, 203490U,\n    319770U, 490314U, 735471U, 1081575U, 1562275U, 2220075U, 3108105U,\n    4292145U, 5852925U, 7888725U, 10518300U},\n  (unsigned long [33]) { // 9\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U, 10U, 55U, 220U, 715U,\n    2002U, 5005U, 11440U, 24310U, 48620U, 92378U, 167960U, 293930U,\n    497420U, 817190U, 1307504U, 2042975U, 3124550U, 4686825U,\n    6906900U, 10015005U, 14307150U, 20160075U, 28048800U},\n  (unsigned long [33]) { // 10\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U, 11U, 66U, 286U, 1001U,\n    3003U, 8008U, 19448U, 43758U, 92378U, 184756U, 352716U,646646U,\n    1144066U, 1961256U, 3268760U, 5311735U, 8436285U, 13123110U,\n    20030010U, 30045015U, 44352165U, 64512240U},\n  (unsigned long [33]) { // 11\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U, 12U, 78U, 364U,\n    1365U, 4368U, 12376U, 31824U, 75582U, 167960U, 352716U, 705432U,\n    1352078U, 2496144U, 4457400U, 7726160U, 13037895U, 21474180U,\n    34597290U, 54627300U, 84672315U, 129024480U},\n  (unsigned long [33]) { // 12\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U, 13U, 91U,\n    455U, 1820U, 6188U, 18564U, 50388U, 125970U, 293930U, 646646U,\n    1352078U, 2704156U, 5200300U, 9657700U, 17383860U, 30421755U,\n    51895935U, 86493225U, 141120525U, 225792840U},\n  (unsigned long [33]) { // 13\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U, 14U, 105U,\n    560U, 2380U, 8568U, 27132U, 77520U, 203490U, 497420U, 1144066U,\n    2496144U, 5200300U, 10400600U, 20058300U, 37442160U, 67863915U,\n    119759850U, 206253075U, 347373600U},\n  (unsigned long [33]) { // 14\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U, 15U,\n    120U, 680U, 3060U, 11628U, 38760U, 116280U, 319770U, 817190U,\n    1961256U, 4457400U, 9657700U, 20058300U, 40116600U, 77558760U,\n    145422675U, 265182525U, 471435600U},\n  (unsigned long [33]) { // 15\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 1U,\n    16U, 136U, 816U, 3876U, 15504U, 54264U, 170544U, 490314U,\n    1307504U, 3268760U, 7726160U, 17383860U, 37442160U, 77558760U,\n    155117520U, 300540195U, 565722720U},\n  (unsigned long [33]) { // 16\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    1U, 17U, 153U, 969U, 4845U, 20349U, 74613U, 245157U,\n    735471U,2042975U, 5311735U, 13037895U, 30421755U, 67863915U,\n    145422675U, 300540195U, 601080390U}};\n\nunsigned long bino(int a, int b) {\n  return table_bino[b][a];\n}\n\nunsigned long cw_coder(int * res, int t) {\n  unsigned long x = 0;\n\n  switch (t) {\n  case 4:\n    x = (res[3] * (res[3] - 1) * (res[3] - 2)) / 6;\n    // calcul de binomial(res[3], 4). Il y a un risque de dpassement,\n    // on peut avoir (res[3] - 3) * x > 2^32\n    switch (x & 3) {\n    case 0:\n      x >>= 2;\n      x *= res[3] - 3;\n      break;\n    case 1:\n    case 3:\n      x *= (res[3] - 3) >> 2;\n      break;\n    case 2:\n      x >>= 1;\n      x *= (res[3] - 3) >> 1;\n      break;\n    }\n  case 3:\n    x += ((unsigned long) (((res[2] * (res[2] - 1)) / 2) * (res[2] - 2))) / 3;\n  case 2:\n    x += ((unsigned long) (res[1] * (res[1] - 1))) / 2;\n  case 1:\n    x += res[0];\n    break;\n  default:\n    x = table_bino[t][res[t - 1]] + cw_coder(res, t - 1);\n    break;\n  }\n\n  return x;\n}\n\n// binomial(i,t) <= x < binomial(i+1,t)\n// par recherche dichotomique\nint inv_bino(unsigned long x, int t) {\n  int debut, fin, milieu;\n\n  debut = t - 1;\n  fin = max_bino[t];\n  milieu = (fin + debut) / 2;\n  // invariants :\n  // table_bino[t][debut] <= x < table_bino[t][fin]\n  // debut <= milieu < fin\n  // fin - milieu - 1 <= milieu - debut <= fin - milieu\n  while (milieu > debut) {\n    if (x < table_bino[t][milieu])\n      fin = milieu;\n    else\n      debut = milieu;\n    milieu = (fin + debut) / 2;\n  }\n  // milieu = debut\n  // fin = debut + 1\n  return debut;\n}\n\nvoid cw_decoder(unsigned long x, int t, int * res) {\n  if (x == 0) {\n    while (t > 0) {\n      t--;\n      res[t] = t;\n    }\n  }\n  else if (t == 1) {\n    res[0] = x;\n  }\n  else if (t == 2) {\n    res[1] = round(sqrt(2 * x + 0.25));\n    res[0] = x - (res[1] * (res[1] - 1)) / 2;\n  }\n  else if (t == 3) {\n    unsigned long b;\n    res[2] = 1 + cbrtf(6 * ((float) x)); // x > 0\n    b = (res[2] * (res[2] - 1)) / 2; // binomial(res[2], 2)\n    // par << chance >>, puisque res[2] <= 2^11, pas de dpassement\n    // on a bien b * (res[2] - 2) < 2^32\n    x -= (b * (res[2] - 2)) / 3; // binomial(res[2], 3)\n    if (x >= b) { // on avait x >= binomial(res[2] + 1, 3)\n      res[2]++;\n      x -= b;\n    }\n    cw_decoder(x, 2, res);\n  }\n  else if (t == 4) {\n    unsigned long b;\n    res[3] = 1 + powf(24 * ((float) x), 0.25); // x > 0\n    b = (res[3] * (res[3] - 1) * (res[3] - 2)) / 6; // binomial(res[3], 3)\n    // calcul de binomial(res[3], 4). Il y a un risque de dpassement,\n    // on peut avoir (res[3] - 3) * b > 2^32\n    switch (b & 3) {\n    case 0:\n      x -= (b >> 2) * (res[3] - 3);\n      break;\n    case 1:\n    case 3:\n      x -= b * ((res[3] - 3) >> 2);\n      break;\n    case 2:\n      x -= (b >> 1) * ((res[3] - 3) >> 1);\n      break;\n    }\n    if (x >= b) { // on avait x >= binomial(res[3] + 1, 4)\n      res[3]++;\n      x -= b;\n    }\n    cw_decoder(x, 3, res);\n  }\n  else {\n    res[t - 1] = inv_bino(x, t);\n    cw_decoder(x - table_bino[t][res[t - 1]], t - 1, res);\n  } \n}\n\nint dicho_rec(int * cw, int i, int s, arith_t state, precomp_t p) {\n  unsigned long u;\n  int j, l, r;\n\n  if (i == 0)\n    return 0;\n\n  if (i > (1 << s) - i) {\n    int * cw2 = malloc(((1 << s) - i) * sizeof (int));\n    r = cw[0] & (((unsigned long) -1) << s);\n    for (j = 0, l = 0; (l < (1 << s) - i) && (j < i); ++r)\n      if (cw[j] == r)\n\t++j;\n      else {\n\tcw2[l] = r;\n\t++l;\n      }\n    for (; l < (1 << s) - i; ++l, ++r)\n      cw2[l] = r;\n    r = dicho_rec(cw2, l, s, state, p);\n    free(cw2);\n    return r;\n  }\n\n  if (i == 1) {\n    liste_todo = liste_alloc(liste_todo);\n    liste_todo->taille = s;\n    liste_todo->nombre = 1;\n    liste_todo->valeur = cw[0] & ((1 << s) - 1);\n    liste_todo->maximum = 1 << s;\n    return 0;\n  }\n\n  if (is_leaf(s, i)) {\n    u = ~((-1) << s);\n    for (j = 0; j < i; ++j)\n      aux[j] = cw[j] & u;\n    liste_todo = liste_alloc(liste_todo);\n    liste_todo->nombre = i;\n    liste_todo->valeur = cw_coder(aux, i);\n    liste_todo->maximum = p.leaf_info[s][i].maximum;\n    liste_todo->taille = p.leaf_info[s][i].deadbits;\n    return 0;\n  }\n\n  for (l = 0; l < i; ++l)\n    if (cw[l] & (1 << (s - 1)))\n      break;\n  r = coder(l, precomp_get_distrib(p, s, i), state);\n\n#ifdef DEBUG\n  printf(\"%d = %d + %d\\n\", i, l, i - l);\n#endif\n\n  r += dicho_rec(cw, l, s - 1, state, p);\n  r += dicho_rec(cw + l, i - l, s - 1, state, p);\n\n  return r;\n}\n\n// n la longueur max,  partir du (n+1)-eme, tous les bits sont nuls (ou ignors)\nint dicho(int * cw, arith_t state, precomp_t p) {\n  int m, t, r, i, accel;\n  liste_t l;\n\n  m = p.m;\n  t = p.t;\n\n  aux = (int *) malloc((t + 1) * sizeof (int));\n  liste_todo = NULL;\n\n  r = dicho_rec(cw, t, m, state, p);\n\n#ifdef DEBUG\n  printf(\"%d\\n\", r);\n  for (l = liste_todo; l != NULL; l = l->suivant)\n    printf(\"%d\\t%d\\t%u\\t%u\\n\", l->nombre, l->taille, l->maximum, l->valeur);\n#endif\n\n  // calcul du nombre i de bits rservs\n  for (i = 0, l = liste_todo; l != NULL; l = l->suivant)\n    i += l->taille;\n\n  // On veut \"rserver\" i bits  la fin de state->buffer. Il\n  // faut prendre en compte le codage arithmtique sachant que nous\n  // devons avoir exactement la mme action ici (au codage) que dans\n  // dichoinv (au dcodage).\n\n  // cela est pris en compte  l'aide de verrous mis en place dans les\n  // fonction de codage et de dcodage\n  accel = (bwrite_unlocked(state->buffer) >= i);\n\n#ifdef DEBUG\n  printf(accel ? \"accel : oui\\n\" : \"accel : non\\n\");\n  printf(\"%d\\t%d\\n\", bwrite_unlocked(state->buffer), i);\n#endif\n\n  if (accel)\n    // les i derniers bits deviennent inaccessibles en criture\n    bwrite_decaler_fin(state->buffer, -i);\n\n  for (l = liste_todo; l != NULL; l = l->suivant) {\n    if (l->nombre > 1) {\n      r += coder_uniforme(l->valeur >> l->taille, l->maximum, state);\n      l->valeur &= ((1 << l->taille) - 1);\n    }\n  }\n\n#ifdef DEBUG\n  printf(\"%d\\n\", r);\n#endif\n\n  if (!accel) {\n    for (l = liste_todo; l != NULL; l = l->suivant) {\n      while (l->taille > PREC_PROBA) {\n\tl->taille -= PREC_PROBA;\n\tr += coder_uniforme(l->valeur >> l->taille, 1 << PREC_PROBA, state);\n\tl->valeur &= ((1 << l->taille) - 1);\n      }\n      r += coder_uniforme(l->valeur, 1 << l->taille, state);\n    }\n  }\n\n  if (state->min == 0) // cas particulier, implique state->compteur == 0\n    bwrite_bit(0, state->buffer);\n  else {\n    bwrite_bit(1, state->buffer);\n    bwrite_bits(0, state->compteur, state->buffer); // ventuellement 0\n  }\n  ++r;\n\n  if (accel) {\n     // les i derniers bits redeviennent accessibles\n    bwrite_decaler_fin(state->buffer, i);\n\n    // on repositionne le pointeur juste avant la zone reserve\n    bwrite_changer_position(state->buffer, state->buffer->fin - i);\n\n    for (l = liste_todo; l != NULL; l = l->suivant)\n      bwrite(l->valeur, l->taille, state->buffer);\n\n    r += i; // i est la somme des l->taille\n  }\n\n#ifdef DEBUG\n  printf(\"%d\\n\", r);\n  for (l = liste_todo; l != NULL; l = l->suivant)\n    printf(\"%d\\t%d\\t%u\\t%u\\n\", l->nombre, l->taille, l->maximum, l->valeur);\n#endif\n\n  free(aux);\n  liste_free(liste_todo);\n\n  return r;\n}\n\nint dichoinv_rec(int * cw, int i, int s, int x, arith_t state, precomp_t p) {\n  int l, r;\n\n  if (i == 0)\n    return 0;\n\n  if (i > (1 << s) - i) {\n    liste_inv = liste_alloc(liste_inv);\n    liste_inv->nombre = i;\n    liste_inv->element = cw;\n    liste_inv->taille = s;\n    liste_inv->pos = x;\n    return dichoinv_rec(cw, (1 << s) - i, s, x, state, p);\n  }\n\n  if (i == 1) {\n    liste_todo = liste_alloc(liste_todo);\n    liste_todo->element = cw;\n    liste_todo->nombre = 1;\n    liste_todo->taille = s;\n    liste_todo->valeur = 0;\n    liste_todo->pos = x;\n    liste_todo->maximum = 1 << s;\n    return 0;\n  }\n\n  if (is_leaf(s, i)) {\n    liste_todo = liste_alloc(liste_todo);\n    liste_todo->element = cw;\n    liste_todo->nombre = i;\n    liste_todo->pos = x;\n    liste_todo->maximum = p.leaf_info[s][i].maximum;\n    liste_todo->taille = p.leaf_info[s][i].deadbits;\n    return 0;\n  }\n\n  r = decoder(precomp_get_distrib(p, s, i), &l, state);\n\n#ifdef DEBUG\n  printf(\"%d = %d + %d\\n\", i, l, i - l);\n#endif\n  r += dichoinv_rec(cw, l, s - 1, x, state, p);\n  r += dichoinv_rec(cw + l, i - l, s - 1, x ^ (1 << (s - 1)), state, p);\n\n  return r;\n}\n\nint dichoinv(int *cw, arith_t state, precomp_t p) {\n  int m, t, r, i, accel;\n  unsigned long x;\n  liste_t l;\n  unsigned char c;\n\n  m = p.m;\n  t = p.t;\n\n  liste_todo = NULL;\n  liste_inv = NULL;\n\n  r = dichoinv_rec(cw, t, m, 0, state, p);\n\n#ifdef DEBUG\n  printf(\"%d\\n\", r);\n  for (l = liste_todo; l != NULL; l = l->suivant)\n    printf(\"%d\\t%d\\t%u\\t%d\\n\", l->nombre, l->taille, l->maximum, l->pos);\n#endif\n\n  // calcul du nombre i de bits rservs\n  for (i = 0, l = liste_todo; l != NULL; l = l->suivant)\n    i += l->taille;\n\n  // cf. discussion dans dicho()\n  accel = (bread_unlocked(state->buffer) >= i);\n\n#ifdef DEBUG\n  printf(accel ? \"accel : oui\\n\" : \"accel : non\\n\");\n  printf(\"%d\\t%d\\n\", bread_unlocked(state->buffer), i);\n#endif\n\n  if (accel)\n    // les i derniers bits du buffer deviennent illisibles (-> '0')\n    bread_decaler_fin(state->buffer, -i);\n\n  for (l = liste_todo; l != NULL; l = l->suivant)\n    if (l->nombre > 1) {\n      r += decoder_uniforme(l->maximum, &x, state);\n      l->valeur = x << l->taille;\n    }\n\n#ifdef DEBUG\n  printf(\"%d\\n\", r);\n#endif\n\n  if (accel) {\n    // les i derniers bits sont de nouveau lisibles\n    bread_decaler_fin(state->buffer, i);\n\n    // et on repositionne le pointeur juste avant la zone reserve\n    bread_changer_position(state->buffer, state->buffer->fin - i);\n\n    for (l = liste_todo; l != NULL; l = l->suivant)\n      l->valeur ^= bread(l->taille, state->buffer);\n\n    r += i; // i est la somme des l->taille\n  }\n  else {\n    for (l = liste_todo; l != NULL; l = l->suivant) {\n      while (l->taille > PREC_PROBA) {\n\tr += decoder_uniforme(1 << PREC_PROBA, &x, state);\n\tl->taille -= PREC_PROBA;\n\tl->valeur ^= x << l->taille;\n      }\n      r += decoder_uniforme(1 << l->taille, &x, state);\n      l->valeur ^= x;\n    }\n  }\n\n  //  ce stade l'tat du codeur arithmtique ne changera plus. En\n  // principe l'amplitude de l'intervalle [min,max[ qu'il contient est\n  // entre 1/4 (exclus) et 1/2 (inclus). Il reste donc un bit \"\n  // lire\". Sa valeur est parfaitement dtermine :\n  //  - il vaut 1 si (state->compteur == 0) et (state->min > 0)\n  //  - il vaut 0 si (state->compteur > 0) ou (state->min == 0)\n  // On incrmente donc r (pour retourner la bonne valeur)\n  ++r;\n\n  // Notons qu'il existe des cas dgnrs dans lesquels l'intervalle\n  // [min,max[ peut avoir une amplitude suprieure  1/2. La valeur\n  // retourne sera alors trop grande. Tel qu'est crit le programme,\n  // ce n'est pas grave, car il teste seulement si la valeur retourne\n  // est suffisamment grande.\n\n  for (l = liste_todo; l != NULL; l = l->suivant) {\n    cw_decoder(l->valeur, l->nombre, l->element);\n    for (i = 0; i < l->nombre; ++i)\n      l->element[i] ^= l->pos;\n  }\n\n#ifdef DEBUG\n  printf(\"%d\\n\", r);\n  for (l = liste_todo; l != NULL; l = l->suivant)\n    printf(\"%d\\t%d\\t%u\\t%u\\t%d\\n\", l->nombre, l->taille, l->maximum, l->valeur, l->pos);\n#endif\n\n  for (l = liste_inv; l != NULL; l = l->suivant) {\n    int j, k;\n    int * cw2;\n    cw2 = malloc(((1 << l->taille) - l->nombre) * sizeof (int));\n    memcpy(cw2, l->element, ((1 << l->taille) - l->nombre) * sizeof (int));\n    i = l->pos;\n    for (j = 0, k = 0; (k < (1 << l->taille) - l->nombre) && (j < l->nombre); ++i)\n      if (cw2[k] == i)\n\t++k;\n      else {\n\tl->element[j] = i;\n\t++j;\n      }\n    for (; j < l->nombre; ++j, ++i)\n      l->element[j] = i;\n    free(cw2);\n  }\n\n#ifdef DEBUG\n  for (i = 0; i < t; ++i) printf(\"%d\\t%d\\n\", i, cw[i]);\n#endif\n\n  liste_free(liste_todo);\n  liste_free(liste_inv);\n\n  return r;\n}\n\n// Transformation d'une squence binaire de longueur l en un mot de\n// poids t et de longueur 2^m.  Cette fonction va lire len bits dans\n// input_message  partir du start-ime bit et les transformer en un\n// mot de poids constant cw (la longueur et le poids du mot sont dans\n// la structure p). Si plus de l > len, les bits aprs le len-ime\n// sont des '0'. La valeur retourne est l.\n\n// Les bits sont numrots du moins significatif au plus\n// significatif. Par exemple le (8*i+j)-ime bit est gal  :\n// (input_message[i] >> j) & 1\n// Le buffer utilis dans le codage arithmtique va lire les bits dans\n// un autre ordre : les octets sont lus dans le mme ordre, mais dans\n// chaque octet le premier bit lu est le bit de poids fort (c'est\n// ncessaire !). D'o la petite manipulation au dbut et  la fin\nint dicho_b2cw(unsigned char * input_message, int * cw, int start, int len, int m, int t, precomp_t p) {\n  int i, j, k, l, end, reduc;\n  arith_t state;\n  unsigned char c, d;\n  int * cw2;\n\n  if ((t != p.real_t) || (m != p.real_m)) {\n    printf(\"inconsistent data for cw, rerun genparams\\n\");\n    exit(0);\n  }\n\n  if (start % 8) {\n    c = input_message[start / 8];\n    input_message[start / 8] >>= (start % 8);\n  }\n  end = start + len;\n  if (end % 8) {\n    d = input_message[end / 8];\n    input_message[end / 8] <<= (8 - (end % 8));\n  }\n\n  state = arith_init(breadinit(input_message, end));\n\n  // la variable p contient 5 champs : distrib qui contient des\n  // probabilits prcalcules, et 4 entiers m, t, real_m et real_t.\n  // Nous gnrons des mots de poids real_t et de longueur\n  // 2^real_m. Le programme peut tre acclr, sans perte\n  // significative d'efficacit, en gnrant des mots de poids t et de\n  // longueur 2^m. Il manque (real_m - m) bits par position qui sont\n  // placs au dbut du buffer, de plus si 2 * real_t > 2^m alors\n  // t = 2^m - real_t\n\n  // On saute les start premiers bits, et, ventuellement, reduc*t\n  // de plus qui serviront  modifier cw  la fin.\n  reduc = m - p.m;\n  bread_changer_position(state->buffer, start + reduc * t);\n\n  cw2 = malloc(p.t * sizeof (int));\n\n  l = dichoinv(cw2, state, p);\n\n  if (p.t == t)\n    memcpy(cw, cw2, t * sizeof (int));\n  else {\n    k = 0;\n    for (j = 0; j < cw2[0]; ++k, ++j)\n      cw[k] = j;\n    for (i = 1; i < p.t; ++i) {\n      for (j = cw2[i - 1] + 1; j < cw2[i]; ++k, ++j)\n\tcw[k] = j;\n    }\n    for (j = cw2[p.t - 1] + 1; j < (1 << m); ++k, ++j)\n      cw[k] = j;\n  }\n  free(cw2);\n\n  if (reduc > 0) {\n    // on revient a start puis on ajuste cw\n    bread_changer_position(state->buffer, start);\n    for (j = 0; j < t; ++j)\n      cw[j] = (cw[j] << reduc) ^ bread(reduc, state->buffer);\n    l += reduc * t;\n  }\n\n  breadclose(state->buffer);\n  free(state);\n\n  if (start % 8) {\n    input_message[start / 8] = c;\n  }\n  if (end % 8) {\n    input_message[end / 8] = d;\n  }\n\n  if (l < len)\n    return -1;\n  else\n    return l;\n}\n\n// Transformation d'un mot de poids t et de longueur 2^m en une\n// squence binaire de longueur l.  Cette fonction va lire un mot de\n// poids constant cw et crire len bits dans output_message  partir\n// du start-ime bit (la longueur et le poids du mot cw sont dans la\n// structure p). Si plus de l > len, les bits  partir du len-ime\n// sont ignors. La valeur retourne est l.\n\n// Les bits sont numrots du moins significatif au plus\n// significatif. Par exemple le (8*i+j)-ime bit est gal  :\n// (output_message[i] >> j) & 1\n// Le buffer utilis dans le codage arithmtique va lire les bits dans\n// un autre ordre : les octets sont lus dans le mme ordre, mais dans\n// chaque octet le premier bit lu est le bit de poids fort (c'est\n// ncessaire !). D'o la petite manipulation au dbut et  la fin.\nint dicho_cw2b(int * cw, unsigned char * output_message, int start, int len, int m, int t, precomp_t p) {\n  int i, j, k, l, end, reduc, mask;\n  arith_t state;\n  bwrite_t b;\n  int * cw2;\n  unsigned char c, d;\n\n  if ((t != p.real_t) || (m != p.real_m)) {\n    printf(\"inconsistent data for cw, rerun genparams\\n\");\n    exit(0);\n  }\n\n  if (start % 8) {\n    c = output_message[start / 8] & ((1 << (start % 8)) - 1);\n    output_message[start / 8] = 0;\n  }\n  end = start + len;\n\n  state = arith_init(bwriteinit(output_message, end));\n  // On saute les start premiers bits\n  bwrite_changer_position(state->buffer, start);\n\n  // la variable p contient 5 champs : distrib qui contient des\n  // probabilits prcalcules, et 4 entiers m, t, real_m et real_t.\n  // Nous gnrons des mots de poids real_t et de longueur\n  // 2^real_m. Le programme peut tre acclr, sans perte\n  // significative d'efficacit, en gnrant des mots de poids t et de\n  // longueur 2^m. Il manque (real_m - m) bits par position qui sont\n  // placs au dbut du buffer, de plus si 2 * real_t > 2^m alors\n  // t = 2^m - real_t.\n\n  reduc = m - p.m;\n  if (reduc > 0) {\n    // On copie les derniers bits de chaque position dans le buffer\n    mask = (1 << reduc) - 1;\n    for (j = 0; j < t; ++j)\n      bwrite(cw[j] & mask, reduc, state->buffer);\n  }\n\n  cw2 = malloc(p.t * sizeof (int));\n\n  if (t == p.t) {\n    for (j = 0; j < t; ++j)\n      cw2[j] = cw[j] >> reduc;\n  }\n  else {\n    k = 0;\n    for (j = 0; j < (cw[0] >> reduc); ++k, ++j)\n      cw2[k] = j;\n    for (i = 1; i < t; ++i) {\n      for (j = (cw[i - 1] >> reduc) + 1; j < (cw[i] >> reduc); ++k, ++j)\n\tcw2[k] = j;\n    }\n    for (j = (cw[t - 1] >> reduc) + 1; j < (1 << m); ++k, ++j)\n      cw2[k] = j;\n  }\n\n  l = reduc * t + dicho(cw2, state, p);\n\n  free(cw2);\n\n  bwriteclose(state->buffer);\n  free(state);\n\n  if (start % 8) {\n    output_message[start / 8] <<= (start % 8);\n    output_message[start / 8] ^= c;\n  }\n  if (end % 8) {\n    output_message[end / 8] >>= (8 - (end % 8));\n  }\n\n  if (l < len)\n    return -1;\n  else\n    return l;\n}\n","/*\n* MCE, the real life implementation of McEliece encryption scheme.\n* Copyright Projet SECRET, INRIA, Rocquencourt and Bhaskar Biswas and \n* Nicolas Sendrier (Bhaskar.Biswas@inria.fr, Nicolas.Sendrier@inria.fr).\n*\n* This is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as\n* published by the Free Software Foundation; either version 2.1 of\n* the License, or (at your option) any later version.\n*\n* This software is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this software; if not, write to the Free\n* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n* 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n*/\n#include <stdlib.h>\n#include <string.h>\n#include \"sizes.h\"\n#include \"dicho.h\"\n#include \"randomize.h\"\n\nextern precomp_t cwdata;\n\n// assumes DIMENSION+CODIMENSION multiple of 8\n// assumes x, a, and b are large enough\nvoid vec_concat(unsigned long* x, unsigned long* a, unsigned long* b)\n{\n  int i, j, k, l;\n\n  if (DIMENSION % 8 == 0) { // and CODIMENSION % 8 == 0\n    memcpy(x, a, BITS_TO_BYTES(DIMENSION));\n    memcpy(((unsigned char *) x) + BITS_TO_BYTES(DIMENSION), b, BITS_TO_BYTES(CODIMENSION));\n  }\n  else {\n    i = DIMENSION - BIT_SIZE_OF_LONG * (DIMENSION / BIT_SIZE_OF_LONG);\n    j = BIT_SIZE_OF_LONG - i;\n    l = DIMENSION / BIT_SIZE_OF_LONG;\n    memcpy(x, a, sizeof (long) * (DIMENSION / BIT_SIZE_OF_LONG));\n    x[l] = a[l] & ((1 << i) - 1); // masking\n\n    for (k = 0; k < CODIMENSION / BIT_SIZE_OF_LONG; ++k) {\n      x[l] ^= b[k] << i;\n      ++l;\n      x[l] = b[k] >> j;\n    }\n    x[l] ^= b[k] << i;\n  }\n}\n\nvoid addto(unsigned long * a, unsigned long * b) {\n  int i;\n\n  for (i = 0; i < BITS_TO_LONG(CODIMENSION); ++i)\n    a[i] ^= b[i];\n}\n\nint encrypt_block(unsigned char *ciphertext, unsigned char *cleartext, const unsigned char * pk)\n{\n  int i, j;\n  unsigned long cR[BITS_TO_LONG(CODIMENSION)], *pt;\n  int e[ERROR_WEIGHT];\n  unsigned char c, d;\n\n  pt = (unsigned long *) pk;\n  memset(cR, 0, BITS_TO_LONG(CODIMENSION) * sizeof(long));\n  for (i = 0; i < DIMENSION / 8; ++i) {\n    for (j = 0; j < 8; ++j) {\n      if (cleartext[i] & (1 << j))\n\taddto(cR, pt);\n      pt += BITS_TO_LONG(CODIMENSION);\n    }\n  }\n  for (j = 0; j < DIMENSION % 8 ; ++j) {\n    if (cleartext[i] & (1 << j))\n      addto(cR, pt);\n    pt += BITS_TO_LONG(CODIMENSION);\n  }\n\n  // generate a constant weight word into e from cleartext, starting\n  // at position DIMENSION and using ERROR_SIZE bits\n  i = dicho_b2cw(cleartext, e,\n\t\t DIMENSION, ERROR_SIZE,\n\t\t LOG_LENGTH, ERROR_WEIGHT, cwdata);\n  // returns the number of bits used (i < 0 if less than ERROR_SIZE\n  // bits are used, this should not happen)\n\n  if (i < 0)\n    return -1;\n\n  // TODO: check the endian problem with the cast\n  vec_concat((unsigned long *) ciphertext, (unsigned long *) cleartext, cR);\n\n  // flip t error positions\n  for (i = 0; i < NB_ERRORS; i++) {\n    ciphertext[e[i] / 8] ^= (1 << (e[i] % 8)); // As 8 is the length of unsigned char.\n  }\n\n  return 1;\n}\n\n// The suffix _ss is for \"semantically secure\", the message is\n// randomized into the cleartext which will de encrypted\nint encrypt_block_ss(unsigned char *ciphertext, unsigned char *message, const unsigned char * pk)\n{\n  unsigned char cleartext[CLEARTEXT_LENGTH];\n\n  randomize(cleartext, message);\n  return encrypt_block(ciphertext, cleartext, pk);\n}\n","/*\n* MCE, the real life implementation of McEliece encryption scheme.\n* Copyright Projet SECRET, INRIA, Rocquencourt and Bhaskar Biswas and \n* Nicolas Sendrier (Bhaskar.Biswas@inria.fr, Nicolas.Sendrier@inria.fr).\n*\n* This is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as\n* published by the Free Software Foundation; either version 2.1 of\n* the License, or (at your option) any later version.\n*\n* This software is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this software; if not, write to the Free\n* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n* 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n*/\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"gf.h\"\n\n#define MAX_EXT_DEG 16//this is our primary consideration....think about changing!?\n\nstatic unsigned prim_poly[MAX_EXT_DEG + 1] = {\n    01,\t\t/* extension degree 0 (!) never used */\n    03,\t\t/* extension degree 1 (!) never used */\n    07, \t\t/* extension degree 2 */\n    013, \t\t/* extension degree 3 */\n    023, \t\t/* extension degree 4 */\n    045, \t\t/* extension degree 5 */\n    0103, \t\t/* extension degree 6 */\n    0203, \t\t/* extension degree 7 */\n    0435, \t\t/* extension degree 8 */\n    01041, \t\t/* extension degree 9 */\n    02011,\t\t/* extension degree 10 */\n    04005,\t\t/* extension degree 11 */\n    010123,\t\t/* extension degree 12 */\n    020033,\t\t/* extension degree 13 */\n    042103,\t\t/* extension degree 14 */\n    0100003,\t\t/* extension degree 15 */\n    0210013\t\t/* extension degree 16 */\n\n};//we predefine the primitive polynomials here.\n\n/*********************************************************************************************/\n////////////////////////////////////GF Functions.//////////////////////////////////////////////\n/*********************************************************************************************/\n\n// construct the table gf_exp[i]=alpha^i\nvoid gf_init_exp() {\n  int i;\n\n  gf_exp = (gf_t *) malloc((1 << gf_extd()) * sizeof (gf_t));\n\n  gf_exp[0] = 1;\n  for (i = 1; i < gf_ord(); ++i) {\n    gf_exp[i] = gf_exp[i - 1] << 1;\n    if (gf_exp[i - 1] & (1 << (gf_extd()-1)))\n      gf_exp[i] ^= prim_poly[gf_extd()];\n  }\n  // hack for the multiplication\n  gf_exp[gf_ord()] = 1;\n}\n\n// construct the table gf_log[alpha^i]=i\nvoid gf_init_log()\n{\n  int i;\n\n  gf_log = (gf_t *) malloc((1 << gf_extd()) * sizeof (gf_t));\n\n  gf_log[0] = gf_ord();//(1 << 16) - 1; // log of 0 par convention\n  for (i = 0; i < gf_ord() ; ++i)\n    gf_log[gf_exp[i]] = i;\n}\n\nint init_done = 0;\n\nint gf_init(int extdeg)\n{\n  if (extdeg > MAX_EXT_DEG) {\n    fprintf(stderr,\"Extension degree %d not implemented !\\n\", extdeg);\n    exit(0);\n  }\n  if (init_done != extdeg) {\n    if (init_done) {\n      free(gf_exp);\n      free(gf_log);\n    }\n    init_done = gf_extension_degree = extdeg;\n    gf_cardinality = 1 << extdeg;\n    gf_multiplicative_order = gf_cardinality - 1;\n    gf_init_exp();\n    gf_init_log();\n  }\n\n  return 1;\n}\n\n// we suppose i >= 0. Par convention 0^0 = 1\ngf_t gf_pow(gf_t x, int i) {\n  if (i == 0)\n    return 1;\n  else if (x == 0)\n    return 0;\n  else {\n    // i mod (q-1)\n    while (i >> gf_extd())\n      i = (i & (gf_ord())) + (i >> gf_extd());\n    i *= gf_log[x];\n    while (i >> gf_extd())\n      i = (i & (gf_ord())) + (i >> gf_extd());\n    return gf_exp[i];\n  }\n}\n\n// u8rnd is a function returning a random byte\ngf_t gf_rand(int (*u8rnd)()) {\n  return (u8rnd() ^ (u8rnd() << 8)) & gf_ord();\n}\n","/*\n* MCE, the real life implementation of McEliece encryption scheme.\n* Copyright Projet SECRET, INRIA, Rocquencourt and Bhaskar Biswas and \n* Nicolas Sendrier (Bhaskar.Biswas@inria.fr, Nicolas.Sendrier@inria.fr).\n*\n* This is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as\n* published by the Free Software Foundation; either version 2.1 of\n* the License, or (at your option) any later version.\n*\n* This software is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this software; if not, write to the Free\n* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n* 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n*/\n#include <stdlib.h>\n#include <string.h>\n#include \"sizes.h\"\n#include \"gf.h\"\n#include \"poly.h\"\n#include \"matrix.h\"\n\nint u8rnd() { return random() & 0xff; }\n\nunsigned int u32rnd() { return u8rnd() ^ (u8rnd()<<8) ^ (u8rnd()<<16) ^ (u8rnd()<<24); }\n\n/*********************************************************************************************/\n////////////////////////////////////KEY-GENERATION Function////////////////////////////////////\n/*********************************************************************************************/\n\n//The support for key-gen\n\nvoid gop_supr(int n,gf_t *L) \n{\n  unsigned int i, j;\n  gf_t tmp;\n\n  for (i = 0; i < n; ++i) \n    {\n      j = i + u32rnd() % (n - i);\n\n      tmp = L[j];\n      L[j] = L[i];\n      L[i] = tmp;\n    }\n}\n\n\nbinmat_t key_genmat(gf_t *L, poly_t g)\n{\n  //L- Support\n  //t- Number of errors, i.e.=30.\n  //n- Length of the Goppa code, i.e.=2^11\n  //m- The extension degree of the GF, i.e. =11\n  //g- The generator polynomial.\n  gf_t x,y;\n  binmat_t H,R; \n  int i,j,k,r,n;\n  int * perm, Laux[LENGTH];\n\n  n=LENGTH;//2^11=2048\n  r=NB_ERRORS*EXT_DEGREE;//32 x 11=352\n\n  H=mat_ini(r,n);//initialize matrix with actual no. of bits.\n  mat_set_to_zero(H); //set the matrix with all 0's.\n\n  for(i=0;i< n;i++)\n    {\n      x = poly_eval(g,L[i]);//evaluate the polynomial at the point L[i].\n      x = gf_inv(x);\n      y = x;\n      for(j=0;j<NB_ERRORS;j++)\n\t{\n\t  for(k=0;k<EXT_DEGREE;k++)\n\t    {\n\t      if(y & (1<<k))//if((y>>k) & 1)\n\t\tmat_set_coeff_to_one(H,j*EXT_DEGREE + k,i);//the co-eff. are set in 2^0,...,2^11 ; 2^0,...,2^11 format along the rows/cols?\n\t    }\n\t  y = gf_mul(y,L[i]);\n\t}\n    }//The H matrix is fed.\n  \n  perm = mat_rref(H);\n  if (perm == NULL) {\n    mat_free(H);\n    return NULL;\n  }\n  \n  R = mat_ini(n-r,r);\n  mat_set_to_zero(R); //set the matrix with all 0's.\n  for (i = 0; i < R->rown; ++i)\n    for (j = 0; j < R->coln; ++j)\n      if (mat_coeff(H,j,perm[i]))\n\tmat_change_coeff(R,i,j);\n\n  for (i = 0; i < LENGTH; ++i)\n    Laux[i] = L[perm[i]];\n  for (i = 0; i < LENGTH; ++i)\n    L[i] = Laux[i];\n\n  mat_free(H);\n  free(perm);\n\n  return (R);\n}\n\nint keypair(unsigned char * sk, unsigned char * pk)\n{\n  int i, j, k, l;\n  unsigned long * pt;\n  gf_t *L, *Linv;\n  poly_t g, *sqrtmod, *F;\n  binmat_t R;\n\n  gf_init(EXT_DEGREE);\n\n  //pick the support.........\n  L = malloc(LENGTH * sizeof(gf_t));\n\n  for(i=0;i<LENGTH;i++)\n    L[i]=i;\n  gop_supr(LENGTH,L);\n\n  do {\n    //pick the irreducible polynomial.....\n    g = poly_randgen_irred(NB_ERRORS, u8rnd);\n    R = key_genmat(L,g);\n    if (R == NULL)\n      poly_free(g);\n  } while (R == NULL);\n\n  sqrtmod = poly_sqrtmod_init(g);\n  F = poly_syndrome_init(g, L, LENGTH);\n\n  // Each F[i] is the (precomputed) syndrome of the error vector with\n  // a single '1' in i-th position.\n  // We do not store the F[i] as polynomials of degree NB_ERRORS, but\n  // as binary vectors of length EXT_DEGREE * NB_ERRORS (this will\n  // speed up the syndrome computation)\n  for (i = 0; i < LENGTH; ++i) {\n    memset(sk, 0, BITS_TO_LONG(CODIMENSION) * sizeof (long));\n    pt = (unsigned long *) sk;\n    for (l = 0; l < NB_ERRORS; ++l) {\n      k = (l * EXT_DEGREE) / BIT_SIZE_OF_LONG;\n      j = (l * EXT_DEGREE) % BIT_SIZE_OF_LONG;\n      pt[k] ^= poly_coeff(F[i], l) << j;\n      if (j + EXT_DEGREE > BIT_SIZE_OF_LONG)\n\tpt[k + 1] ^= poly_coeff(F[i], l) >> (BIT_SIZE_OF_LONG - j);\n    }\n    sk += BITS_TO_LONG(CODIMENSION) * sizeof (long);\n    poly_free(F[i]);\n  }\n  free(F);\n\n  // We need the support L for decoding (decryption). In fact the\n  // inverse is needed\n  Linv = malloc(LENGTH * sizeof (gf_t));\n  for (i = 0; i < LENGTH; ++i)\n    Linv[L[i]] = i;\n  memcpy(sk, Linv, LENGTH * sizeof (gf_t));\n  sk += LENGTH * sizeof (gf_t);\n  free(L);\n  free(Linv);\n\n  memcpy(sk, g->coeff, (NB_ERRORS + 1) * sizeof (gf_t));\n  sk += (NB_ERRORS + 1) * sizeof (gf_t);\n  poly_free(g);\n\n  for (i = 0; i < NB_ERRORS; ++i) {\n    memcpy(sk, sqrtmod[i]->coeff, NB_ERRORS * sizeof (gf_t));\n    sk += NB_ERRORS * sizeof (gf_t);\n    poly_free(sqrtmod[i]);\n  }\n  free(sqrtmod);\n\n  memcpy(pk, R->elem, R->alloc_size);\n  mat_free(R);\n\n  return 1;\n}\n","/*\n* MCE, the real life implementation of McEliece encryption scheme.\n* Copyright Projet SECRET, INRIA, Rocquencourt and Bhaskar Biswas and \n* Nicolas Sendrier (Bhaskar.Biswas@inria.fr, Nicolas.Sendrier@inria.fr).\n*\n* This is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as\n* published by the Free Software Foundation; either version 2.1 of\n* the License, or (at your option) any later version.\n*\n* This software is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this software; if not, write to the Free\n* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n* 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"matrix.h\"\n\n/*********************************************************************************************/\n////////////////////////////////////MATRIX Functions///////////////////////////////////////////\n/*********************************************************************************************/\n\n//take a look at the MSB-LSB format???\n\nbinmat_t mat_ini (int rown, int coln)\n{\n  binmat_t A;\n\n  A = (binmat_t) malloc (sizeof (struct matrix));\n  A->coln = coln;\n  A->rown = rown;  \n  A->rwdcnt = (1 + (coln - 1) / BITS_PER_LONG);\n  A->alloc_size = rown * A->rwdcnt * sizeof (unsigned long);\n  A->elem = (unsigned long *)malloc(A->alloc_size);\n  return A;\n}\n\n// assumes s has the proper allocated size\nbinmat_t mat_ini_from_string(int rown, int coln, const unsigned char * s)\n{\n  binmat_t A;\n\n  A = (binmat_t) malloc (sizeof (struct matrix));\n  A->coln = coln;\n  A->rown = rown;  \n  A->rwdcnt = (1 + (coln - 1) / BITS_PER_LONG);\n  A->alloc_size = rown * A->rwdcnt * sizeof (unsigned long);\n  A->elem = (unsigned long *) s;\n  return A;\n}\n\nvoid mat_free(binmat_t A)\n{\n  free(A->elem);\n  free(A);\n}\n\nbinmat_t mat_copy(binmat_t A)//copying matrix (for the form [G|I].....)\n{\n  binmat_t X;\n  int i;\n  \n  X=mat_ini(A->rown,A->coln);//initialize the matrix.\n  for(i=0;i<((A->rwdcnt)*(A->rown));i++)\n    X->elem[i]=A->elem[i];\n\n  return(X);\n}\n\nbinmat_t mat_rowxor(binmat_t A,int a, int b)\n{\n  int i;\n  for(i=0;i<A->rwdcnt;i++)\n    {\n      A->elem[a*A->rwdcnt+i]^=A->elem[b*A->rwdcnt+i];\n    }\n  return A;\n}\n\n//the matrix is reduced from LSB...(from right)\n\n\nint * mat_rref(binmat_t A)\n{\n  int i,j,failcnt,findrow,max=A->coln - 1;\n  int *perm;\n\n  perm = malloc(A->coln * sizeof(int));\n\n  for(i=0;i<A->coln;i++)\n    perm[i]=i;//initialize permutation.\n  failcnt = 0;\n\n  for(i=0;i<A->rown;i++,max--)\n    {\n      findrow=0;\n      for(j=i;j<A->rown;j++)\n\t{\n\t  if(mat_coeff(A,j,max))//(A->elem[(j*A->coln)+max])\n\t    {\n\t      //max--;\n\t      if (i!=j)//not needed as ith row is 0 and jth row is 1.\n\t\tA=mat_rowxor(A,i,j);//xor to the row.(swap)?\n\t      findrow=1;\n\t      break;\n\t    }//largest value found (end if)\n\t  //\t\t  break;\n\t}\n\n      if(!findrow)//if no row with a 1 found then swap last column and the column with no 1 down.\n\t{\n\t  perm[A->coln - A->rown - 1 - failcnt] = max;\n\t  failcnt++;\n\t  if (!max)\n\t    {\n\t      return NULL;\n\t    }\n\t  i--;\n\t}\n      else\n\t{\n\t  perm[i+A->coln - A->rown] = max;\n\t  for(j=i+1;j<A->rown;j++)//fill the column downwards with 0's\n\t    {\n\t      if(mat_coeff(A,j,(max)))//(A->elem[j*A->coln+max+1])\n\t\tA=mat_rowxor(A,j,i);//check the arg. order.\n\t    }\n\n\t  for(j=i-1;j>=0;j--)//fill the column with 0's upwards too.\n\t    {\n\t      if(mat_coeff(A,j,(max)))//(A->elem[j*A->coln+max+1])\n\t\tA=mat_rowxor(A,j,i);\n\t    }\n\t}\n    }//end for(i)\n\n  return(perm);\n}\n\nvoid mat_vec_mul(unsigned long *cR, unsigned char *x, binmat_t A)\n{\n  int i,j;\n  unsigned long *pt;\n\n  memset(cR,0,A->rwdcnt*sizeof(long));\n  pt = A->elem;\n  for(i=0;i<A->rown;i++)//extract the first column in the form of char array.\n    {\n      if((x[i/8]>>(i%8))&1)\n\tfor (j = 0; j < A->rwdcnt; ++j)\n\t  cR[j] ^= *pt++;\n      else\n\tpt += A->rwdcnt;\n    }\n}\n\nbinmat_t mat_mul(binmat_t A, binmat_t B)\n{\n  binmat_t C;\n  int i,j,k;\n\n  if (A->coln != B->rown)\n    exit(0);\n\n  C = mat_ini(A->rown, B->coln);\n  memset(C->elem,0,C->alloc_size);\n  for(i=0;i<A->rown;i++)\n    for(j=0;j<B->coln;j++)\n      for (k = 0; k < A->coln; ++k)\n\tif (mat_coeff(A,i,k) && mat_coeff(B,k,j))\n\t  mat_change_coeff(C,i,j);\n\n  return C;\n}\n\n","/*\n* MCE, the real life implementation of McEliece encryption scheme.\n* Copyright Projet SECRET, INRIA, Rocquencourt and Bhaskar Biswas and \n* Nicolas Sendrier (Bhaskar.Biswas@inria.fr, Nicolas.Sendrier@inria.fr).\n*\n* This is free software; you can redistribute it and/or modify it\n* under the terms of the GNU Lesser General Public License as\n* published by the Free Software Foundation; either version 2.1 of\n* the License, or (at your option) any later version.\n*\n* This software is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n* Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public\n* License along with this software; if not, write to the Free\n* Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n* 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"gf.h\"\n#include \"poly.h\"\n\n/*********************************************************************************************/\n////////////////////////////////////POLYNOMIAL Functions///////////////////////////////////////\n/*********************************************************************************************/\n\npoly_t poly_alloc(int d) {\n  poly_t p;\n\n  p = (poly_t) malloc(sizeof (struct polynome));\n  p->deg = -1;\n  p->size = d + 1;\n  p->coeff = (gf_t *) calloc(p->size, sizeof (gf_t));\n  return p;\n}\n\n// assumes s has the proper allocated size\npoly_t poly_alloc_from_string(int d, const unsigned char * s) {\n  poly_t p;\n\n  p = (poly_t) malloc(sizeof (struct polynome));\n  p->deg = -1;\n  p->size = d + 1;\n  p->coeff = (gf_t *) s;\n  return p;\n}\n\npoly_t poly_copy(poly_t p) {\n  poly_t q;\n\n  q = (poly_t) malloc(sizeof (struct polynome));\n  q->deg = p->deg;\n  q->size = p->size;\n  q->coeff = (gf_t *) calloc(q->size, sizeof (gf_t));\n  memcpy(q->coeff, p->coeff, p->size * sizeof (gf_t));\n  return q;\n}\n\nvoid poly_free(poly_t p) {\n  free(p->coeff);\n  free(p);\n}\n\nvoid poly_set_to_zero(poly_t p) {\n  memset(p->coeff, 0, p->size * sizeof (gf_t));\n  p->deg = -1;\n}\n\nint poly_calcule_deg(poly_t p) {\n  int d = p->size - 1;\n  while ((d >= 0) && (p->coeff[d] == gf_zero()))\n    --d;\n  p->deg = d;\n  return d;\n}\n\n// copy q in p\nvoid poly_set(poly_t p, poly_t q) {\n  int d = p->size - q->size;\n  if (d < 0) {\n    memcpy(p->coeff, q->coeff, p->size * sizeof (gf_t));\n    poly_calcule_deg(p);\n  }\n  else {\n    memcpy(p->coeff, q->coeff, q->size * sizeof (gf_t));\n    memset(p->coeff + q->size, 0, d * sizeof (gf_t));\n    p->deg = q->deg;\n  }\n}\n\ngf_t poly_eval_aux(gf_t * coeff, gf_t a, int d) {\n  gf_t b;\n\n  b = coeff[d--];\n  for (; d >= 0; --d)\n    if (b != gf_zero())\n      b = gf_add(gf_mul(b, a), coeff[d]);\n    else\n      b = coeff[d];\n  return b;\n}\n\npoly_t poly_mul(poly_t p, poly_t q) {\n  int i,j,dp,dq;\n  poly_t r;\n\n  poly_calcule_deg(p);\n  poly_calcule_deg(q);\n  dp = poly_deg(p);\n  dq = poly_deg(q);\n  r=poly_alloc(dp+dq);\n  for (i = 0; i <= dp; ++i)\n    for (j = 0; j <= dq; ++j)\n      poly_addto_coeff(r,i+j,gf_mul(poly_coeff(p,i),poly_coeff(q,j)));\n  poly_calcule_deg(r);\n\n  return(r);\n}\n\ngf_t poly_eval(poly_t p, gf_t a) {\n  return poly_eval_aux(p->coeff, a, poly_deg(p));\n}\n\n// p contain it's remainder modulo g\nvoid poly_rem(poly_t p, poly_t g) {\n  int i, j, d;\n  gf_t a, b;\n\n  d = poly_deg(p) - poly_deg(g);\n  if (d >= 0) {\n    a = gf_inv(poly_tete(g));\n    for (i = poly_deg(p); d >= 0; --i, --d) {\n      if (poly_coeff(p, i) != gf_zero()) {\n\tb = gf_mul_fast(a, poly_coeff(p, i));\n\tfor (j = 0; j < poly_deg(g); ++j)\n\t  poly_addto_coeff(p, j + d, gf_mul_fast(b, poly_coeff(g, j)));\n\tpoly_set_coeff(p, i, gf_zero());\n      }\n    }\n    poly_set_deg(p, poly_deg(g) - 1);\n    while ((poly_deg(p) >= 0) && (poly_coeff(p, poly_deg(p)) == gf_zero()))\n      poly_set_deg(p, poly_deg(p) - 1);\n  }\n}\n\nvoid poly_sqmod_init(poly_t g, poly_t * sq) {\n  int i, d;\n\n  d = poly_deg(g);\n\n  for (i = 0; i < d / 2; ++i) {\n    // sq[i] = x^(2i) mod g = x^(2i)\n    poly_set_to_zero(sq[i]);\n    poly_set_deg(sq[i], 2 * i);\n    poly_set_coeff(sq[i], 2 * i, gf_unit());\n  }\n\n  for (; i < d; ++i) {\n    // sq[i] = x^(2i) mod g = (x^2 * sq[i-1]) mod g\n    memset(sq[i]->coeff, 0, 2 * sizeof (gf_t));\n    memcpy(sq[i]->coeff + 2, sq[i - 1]->coeff, d * sizeof (gf_t));\n    poly_set_deg(sq[i], poly_deg(sq[i - 1]) + 2);\n    poly_rem(sq[i], g);\n  }\n}\n\n/*Modulo p square of a certain polynomial g, sq[] contains the square\nModulo g of the base canonical polynomials of degree < d, where d is\nthe degree of G. The table sq[] will be calculated by poly_sqmod_init*/\n\nvoid poly_sqmod(poly_t res, poly_t p, poly_t * sq, int d) {\n  int i, j;\n  gf_t a;\n\n  poly_set_to_zero(res);\n\n  // terms of low degree\n  for (i = 0; i < d / 2; ++i)\n    poly_set_coeff(res, i * 2, gf_square(poly_coeff(p, i)));\n\n  // terms of high degree\n  for (; i < d; ++i) {\n    if (poly_coeff(p, i) != gf_zero()) {\n      a = gf_square(poly_coeff(p, i));\n      for (j = 0; j < d; ++j)\n\tpoly_addto_coeff(res, j, gf_mul_fast(a, poly_coeff(sq[i], j)));\n    }\n  }\n\n  // Update degre\n  poly_set_deg(res, d - 1);\n  while ((poly_deg(res) >= 0) && (poly_coeff(res, poly_deg(res)) == gf_zero()))\n    poly_set_deg(res, poly_deg(res) - 1);\n}\n\n// destructive\npoly_t poly_gcd_aux(poly_t p1, poly_t p2) {\n  if (poly_deg(p2) == -1)\n    return p1;\n  else {\n    poly_rem(p1, p2);\n    return poly_gcd_aux(p2, p1);\n  }\n}\n\npoly_t poly_gcd(poly_t p1, poly_t p2) {\n  poly_t a, b, c;\n\n  a = poly_copy(p1);\n  b = poly_copy(p2);\n  if (poly_deg(a) < poly_deg(b))\n    c = poly_copy(poly_gcd_aux(b, a));\n  else\n    c = poly_copy(poly_gcd_aux(a, b));\n  poly_free(a);\n  poly_free(b);\n  return c;\n}\n\npoly_t poly_quo(poly_t p, poly_t d) {\n  int i, j, dd, dp;\n  gf_t a, b;\n  poly_t quo, rem;\n\n  dd = poly_calcule_deg(d);\n  dp = poly_calcule_deg(p);\n  rem = poly_copy(p);\n  quo = poly_alloc(dp - dd);\n  poly_set_deg(quo, dp - dd);\n  a = gf_inv(poly_coeff(d, dd));\n  for (i = dp; i >= dd; --i) {\n    b = gf_mul_fast(a, poly_coeff(rem, i));\n    poly_set_coeff(quo, i - dd, b);\n    if (b != gf_zero()) {\n      poly_set_coeff(rem, i, gf_zero());\n      for (j = i - 1; j >= i - dd; --j)\n\tpoly_addto_coeff(rem, j, gf_mul_fast(b, poly_coeff(d, dd - i + j)));\n    }\n  }\n  poly_free(rem);\n\n  return quo;\n}\n\n// Returns the degree of the smallest factor\nint poly_degppf(poly_t g) {\n  int i, d, res;\n  poly_t *u, p, r, s;\n\n  d = poly_deg(g);\n  u = malloc(d * sizeof (poly_t *));\n  for (i = 0; i < d; ++i)\n    u[i] = poly_alloc(d + 1);\n  poly_sqmod_init(g, u);\n\n  p = poly_alloc(d - 1);\n  poly_set_deg(p, 1);\n  poly_set_coeff(p, 1, gf_unit());\n  r = poly_alloc(d - 1);\n  res = d;\n  for (i = 1; i <= (d / 2) * gf_extd(); ++i) {\n    poly_sqmod(r, p, u, d);\n    // r = x^(2^i) mod g\n    if ((i % gf_extd()) == 0) { // so 2^i = (2^m)^j (m ext. degree)\n      poly_addto_coeff(r, 1, gf_unit());\n      poly_calcule_deg(r); // The degree may change\n      s = poly_gcd(g, r);\n      if (poly_deg(s) > 0) {\n\tpoly_free(s);\n\tres = i / gf_extd();\n\tbreak;\n      }\n      poly_free(s);\n      poly_addto_coeff(r, 1, gf_unit());\n      poly_calcule_deg(r); // The degree may change\n    }\n    // No need for the exchange s\n    s = p;\n    p = r;\n    r = s;\n  }\n\n  poly_free(p);\n  poly_free(r);\n  for (i = 0; i < d; ++i) {\n    poly_free(u[i]);\n  }\n  free(u);\n\n  return res;\n}\n\n// We suppose deg(g) >= deg(p)\nvoid poly_eeaux(poly_t * u, poly_t * v, poly_t p, poly_t g, int t) {\n  int i, j, dr, du, delta;\n  gf_t a;\n  poly_t aux, r0, r1, u0, u1;\n\n  // initialisation of the local variables\n  // r0 <- g, r1 <- p, u0 <- 0, u1 <- 1\n  dr = poly_deg(g);\n\n  r0 = poly_alloc(dr);\n  r1 = poly_alloc(dr - 1);\n  u0 = poly_alloc(dr - 1);\n  u1 = poly_alloc(dr - 1);\n  poly_set(r0, g);\n  poly_set(r1, p);\n  poly_set_to_zero(u0);\n  poly_set_to_zero(u1);\n  poly_set_coeff(u1, 0, gf_unit());\n  poly_set_deg(u1, 0);\n\n  // invariants:\n  // r1 = u1 * p + v1 * g\n  // r0 = u0 * p + v0 * g\n  // and deg(u1) = deg(g) - deg(r0)\n  // It stops when deg (r1) <t (deg (r0)> = t)\n  // And therefore deg (u1) = deg (g) - deg (r0) <deg (g) - t\n  du = 0;\n  dr = poly_deg(r1);\n  delta = poly_deg(r0) - dr;\n\n  while (dr >= t) {\n    for (j = delta; j >= 0; --j) {\n      a = gf_div(poly_coeff(r0, dr + j), poly_coeff(r1, dr));\n      if (a != gf_zero()) {\n\t// u0(z) <- u0(z) + a * u1(z) * z^j\n\tfor (i = 0; i <= du; ++i){\n\t  poly_addto_coeff(u0, i + j, gf_mul_fast(a, poly_coeff(u1, i)));\n\t}\n\t// r0(z) <- r0(z) + a * r1(z) * z^j\n\tfor (i = 0; i <= dr; ++i)\n\t  poly_addto_coeff(r0, i + j, gf_mul_fast(a, poly_coeff(r1, i)));\n      }\n    }\n    // exchange\n    aux = r0; r0 = r1; r1 = aux;\n    aux = u0; u0 = u1; u1 = aux;\n\n    du = du + delta;\n    delta = 1;\n    while (poly_coeff(r1, dr - delta) == gf_zero())\n      delta++;\n    dr -= delta;\n  }\n\n  poly_set_deg(u1, du);\n  poly_set_deg(r1, dr);\n  //return u1 and r1;\n  *u=u1;\n  *v=r1;\n\n  poly_free(r0);\n  poly_free(u0);\n}\n\n// The field is already defined\n// Return a polynomial of degree t irreducible in the field\npoly_t poly_randgen_irred(int t, int (*u8rnd)()) {\n  int i;\n  poly_t g;\n\n  g = poly_alloc(t);\n  poly_set_deg(g, t);\n  poly_set_coeff(g, t, gf_unit());\n\n  i = 0;\n  do\n    for (i = 0; i < t; ++i)\n      poly_set_coeff(g, i, gf_rand(u8rnd));\n  while (poly_degppf(g) < t);\n\n  return g;\n}\n\n\n// p = p * x mod g\n// p of degree <= deg(g)-1\nvoid poly_shiftmod(poly_t p, poly_t g) {\n  int i, t;\n  gf_t a;\n\n  t = poly_deg(g);\n  a = gf_div(p->coeff[t-1], g->coeff[t]);\n  for (i = t - 1; i > 0; --i)\n    p->coeff[i] = gf_add(p->coeff[i - 1], gf_mul(a, g->coeff[i]));\n  p->coeff[0] = gf_mul(a, g->coeff[0]);\n}\n\npoly_t * poly_sqrtmod_init(poly_t g) {\n  int i, t;\n  poly_t * sqrt, aux, p, q, * sq_aux;\n\n  t = poly_deg(g);\n\n  sq_aux = malloc(t * sizeof (poly_t));\n  for (i = 0; i < t; ++i)\n    sq_aux[i] = poly_alloc(t + 1);\n  poly_sqmod_init(g, sq_aux);\n\n  q = poly_alloc(t - 1);\n  p = poly_alloc(t - 1);\n  poly_set_deg(p, 1);\n\n  poly_set_coeff(p, 1, gf_unit());\n  // q(z) = 0, p(z) = z\n  for (i = 0; i < t * gf_extd() - 1; ++i) {\n    // q(z) <- p(z)^2 mod g(z)\n    poly_sqmod(q, p, sq_aux, t);\n    // q(z) <-> p(z)\n    aux = q; q = p; p = aux;\n  }\n  // p(z) = z^(2^(tm-1)) mod g(z) = sqrt(z) mod g(z)\n\n  sqrt = malloc(t * sizeof (poly_t));\n  for (i = 0; i < t; ++i)\n    sqrt[i] = poly_alloc(t - 1);\n\n  poly_set(sqrt[1], p);\n  poly_calcule_deg(sqrt[1]);\n  for(i = 3; i < t; i += 2) {\n    poly_set(sqrt[i], sqrt[i - 2]);\n    poly_shiftmod(sqrt[i], g);\n    poly_calcule_deg(sqrt[i]);\n  }\n\n  for (i = 0; i < t; i += 2) {\n    poly_set_to_zero(sqrt[i]);\n    sqrt[i]->coeff[i / 2] = gf_unit();\n    sqrt[i]->deg = i / 2;\n  }\n\n  for (i = 0; i < t; ++i)\n    poly_free(sq_aux[i]);\n  free(sq_aux);\n  poly_free(p);\n  poly_free(q);\n\n  return sqrt;\n}\n\npoly_t * poly_syndrome_init(poly_t generator, gf_t *support, int n)\n{\n  int i,j,t;\n  gf_t a;\n  poly_t * F;\n\n  F = malloc(n * sizeof (poly_t));\n  t = poly_deg(generator);\n\n  //g(z)=g_t+g_(t-1).z^(t-1)+......+g_1.z+g_0\n  //f(z)=f_(t-1).z^(t-1)+......+f_1.z+f_0\n\n  for(j=0;j<n;j++)\n    {\n      F[j] = poly_alloc(t-1);\n      poly_set_coeff(F[j],t-1,gf_unit());\n      for(i=t-2;i>=0;i--)\n\t{\n\t  poly_set_coeff(F[j],i,gf_add(poly_coeff(generator,i+1),\n\t\t\t\t       gf_mul(support[j],poly_coeff(F[j],i+1))));\n\t}\n      a = gf_add(poly_coeff(generator,0),gf_mul(support[j],poly_coeff(F[j],0)));\n      for(i=0;i<t;i++)\n\t{\n\t  poly_set_coeff(F[j],i, gf_div(poly_coeff(F[j],i),a));\n\t}\n    }\n\n  return F;\n}\n","#include <stdlib.h>\n#include <time.h>\n#include \"mceliece.h\"\n#include \"randombytes.h\"\n#include \"sizes.h\"\n\n\nvoid mceliecejs_init () {\n\tsize_t randomstate_len\t= 256;\n\tchar* randomstate\t\t= (char*) malloc(randomstate_len);\n\n\trandombytes_stir();\n\trandombytes_buf(randomstate, randomstate_len);\n\tinitstate(time(NULL), randomstate, randomstate_len);\n}\n\nlong mceliecejs_public_key_bytes () {\n\treturn PUBLICKEY_BYTES;\n}\n\nlong mceliecejs_private_key_bytes () {\n\treturn SECRETKEY_BYTES;\n}\n\nlong mceliecejs_encrypted_bytes () {\n\treturn CIPHERTEXT_BYTES;\n}\n\nlong mceliecejs_decrypted_bytes () {\n\treturn CLEARTEXT_BYTES;\n}\n\nlong mceliecejs_message_bytes () {\n\treturn MESSAGE_BYTES - 5;\n}\n\nvoid mceliecejs_keypair (\n\tuint8_t* public_key,\n\tuint8_t* private_key\n) {\n\tkeypair(private_key, public_key);\n}\n\nvoid mceliecejs_encrypt (\n\tuint8_t* message,\n\tuint8_t* public_key,\n\tuint8_t* cyphertext\n) {\n\tencrypt_block(cyphertext, message, public_key);\n}\n\nvoid mceliecejs_decrypt (\n\tuint8_t* cyphertext,\n\tuint8_t* private_key,\n\tuint8_t* decrypted\n) {\n\tdecrypt_block(decrypted, cyphertext, private_key);\n}\n"]}